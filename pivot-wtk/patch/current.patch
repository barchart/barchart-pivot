diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
index eb23b16..7cc2c4f 100644
--- a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
@@ -85,7 +85,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         private static final long serialVersionUID = 0;
 
         private transient Window rootOwner = null;
-        private transient Runnable updateHostWindowTitleBarCallback = null;
+        private transient Runnable updateHostWindowTitleBarCallback = null;//something somewhere
 
         private transient WindowListener rootOwnerListener = new WindowListener.Adapter() {
             @Override
@@ -192,6 +192,22 @@ public final class DesktopApplicationContext extends ApplicationContext {
             }
         }
     }
+    
+    /**
+     * Returns an {@link EventEnabledFrame} if the java version is greater
+     * than or equal to 7. The returned frame is capable of painting its own
+     * title bar so that move events on the frame (normally not able to
+     * be received), can be dispatched.
+     * 
+     * @return	an instance of EventEnabledFrame
+     */
+    protected static HostFrame getHostFrame() {
+    	if(isRunningVersion7OrGreater()) {
+    		System.out.println("Running extended capability pivot fork.");
+    		return new DesktopFrame();
+    	}
+    	return new HostFrame();
+    }
 
     // The AWT Window class does not define a title property; this interface allows
     // the HostFrame and HostDialog titles to be handled polymorphically
@@ -201,11 +217,13 @@ public final class DesktopApplicationContext extends ApplicationContext {
     }
 
     // Native host frame
-    private static class HostFrame extends java.awt.Frame implements TitledWindow {
+    //David Ray : Forked change of access level (from private to protected) to this class and its extention
+    //			  to javax.swing.JFrame from java.awt.Frame
+    protected static class HostFrame extends javax.swing.JFrame implements TitledWindow {
         private static final long serialVersionUID = 5340356674429280196L;
 
         public HostFrame() {
-            enableEvents(AWTEvent.WINDOW_EVENT_MASK
+        	enableEvents(AWTEvent.WINDOW_EVENT_MASK
                 | AWTEvent.WINDOW_STATE_EVENT_MASK);
 
             // Disable focus traversal keys
@@ -479,7 +497,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         boolean center = false;
         boolean resizable = true;
         boolean maximized = false;
-        boolean undecorated = false;
+        boolean undecorated = isRunningVersion7OrGreater();
         boolean fullScreen = false;
         boolean preserveSplashScreen = false;
 
@@ -564,7 +582,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         displays.add(primaryDisplayHost.getDisplay());
 
         // Create the windowed host frame
-        windowedHostFrame = new HostFrame();
+        windowedHostFrame = getHostFrame();
         windowedHostFrame.add(primaryDisplayHost);
         windowedHostFrame.setUndecorated(undecorated);
 
@@ -647,6 +665,18 @@ public final class DesktopApplicationContext extends ApplicationContext {
             });
         }
     }
+    
+    /**
+     * Called from the declaration of "undecorated" which calls
+     * {@link #isRunningVersion7OrGreater()} to determine if it is
+     * safe to create a custom barchart frame.
+     * 
+     * @return	flag indicating whether the java version is >= 1.7
+     */
+    private static boolean isRunningVersion7OrGreater() {
+    	String version = System.getProperty("java.version");
+    	return Integer.parseInt(version.split("\\.")[1]) >= 7;
+    }
 
     private static void initializeOSExtensions() {
         String osName = System.getProperty("os.name");
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
new file mode 100644
index 0000000..b3960bb
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
@@ -0,0 +1,923 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Cursor;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.MouseInfo;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseMotionListener;
+import java.awt.geom.Arc2D;
+import java.awt.geom.Area;
+import java.awt.image.BufferedImage;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.swing.JComponent;
+import javax.swing.JFrame;
+import javax.swing.JMenuBar;
+import javax.swing.JPanel;
+import javax.swing.event.MouseInputAdapter;
+
+
+/**
+ * Sub-class of {@link JFrame} which supports custom frame movement
+ * functionality
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public class DesktopFrame extends DesktopApplicationContext.HostFrame {
+    /** The JComponent shown as the title bar decoration */
+    private TitleBar titleBar;
+    /** The default height of the title bar */
+    private int titleBarHeight = 22;
+    /** The main content panel housing the user content */
+    private JPanel mainContentPanel;
+    /** The left border component which detects mouse events for cursor manipulation and resizing */
+    private JComponent leftBorderComponent;
+    /** The right border component which detects mouse events for cursor manipulation and resizing */
+    private JComponent rightBorderComponent;
+    /** The bottom border component which detects mouse events for cursor manipulation and resizing */
+    private JComponent bottomBorderComponent;
+    
+    private Component userPanel; 
+    
+    private CursorManager cursorManager;
+    
+    private boolean isBorderDecorated;
+    /** Container of both the title bar and optional JMenuBar */
+    private JPanel titlebarContainer;
+    /** The optional JMenuBar */
+    private JMenuBar menuBar;
+    
+    private int borderSize = 1;
+    private int resizeMargin = borderSize;
+    
+    private Color borderColor = new Color(120, 120, 120);
+    
+    private List<Rectangle> virtualDeviceBounds;
+    private Area virtualArea;
+    
+    private BufferedImage storedImage;
+    private boolean isDragging;
+    private boolean isResizing;
+    
+    private List<DragListener> dragListeners = new ArrayList<DragListener>();
+    
+    
+    
+    
+    /**
+     * Constructs a new {@code DesktopFrame}
+     * 
+     * @param title     the String to be used as the title.
+     * @param gc        the GraphicsConfiguration to be used.
+     */
+    public DesktopFrame() {
+        setUndecorated(true);
+        super.setLayout(new BorderLayout());
+        setTitleBar(createTitleBar());
+        
+        //The following 3 lines are temporary as location/size info for development.
+        JPanel p = createMainContentPanel();
+        addMainContentPanel(p);
+        setBorderDecorated(true, true);
+        addCursorHandler();
+        reshapeBorders();
+        installManager(new MouseHandler());
+        
+        getEnvironmentInfo();
+        
+    }
+    
+    /**
+     * Adds the specified {@link DragListener} to this {@code DesktopFrame}
+     * @param d		the {@code DragListener} to add.
+     */
+    public void addDragListener(DragListener d) {
+    	if(d != null) {
+    		dragListeners.add(d);
+    	}
+    }
+    
+    /**
+     * Fires a window dragged event to registered listeners.
+     * 
+     * @param oldLoc
+     * @param newLoc
+     */
+    public void fireWindowDragged(Point oldLoc, Point newLoc) {
+    	for(DragListener l : dragListeners) {
+    		l.windowDragged(oldLoc, newLoc);
+    	}
+    }
+    
+    /**
+     * Fires an event notifiying {@link DragListener}s that
+     * dragging has stopped.
+     */
+    public void fireDraggingStopped() {
+    	for(DragListener l : dragListeners) {
+    		l.draggingStopped();
+    	}
+    }
+    
+    /**
+     * Gathers and stores information about the graphics environment
+     * such as the combined screen area of a multiscreen environment
+     * and the shape its bounding polygon.
+     */
+    private void getEnvironmentInfo() {
+    	 GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
+         GraphicsDevice[] gs = ge.getScreenDevices();
+         virtualDeviceBounds = new ArrayList<Rectangle>();
+         virtualArea = new Area();
+         for (int j = 0; j < gs.length; j++) {
+             GraphicsDevice gd = gs[j];
+             GraphicsConfiguration[] gc = gd.getConfigurations();
+             for (int i=0; i < gc.length; i++) {
+            	 Rectangle r = gc[i].getBounds();
+            	 java.awt.Insets screenInsets = Toolkit.getDefaultToolkit().getScreenInsets(gc[i]);
+            	 r.x = r.x + screenInsets.left;
+            	 r.y = r.y + screenInsets.top;
+            	 r.setSize(r.width - (screenInsets.left + screenInsets.right),
+            		r.height - (screenInsets.top + screenInsets.bottom));
+            	 virtualDeviceBounds.add(r);
+            	 virtualArea.add(new Area(r));
+             }
+         } 
+    }
+    
+    /**
+     * Protects against a frame location being out of aggregate
+     * device bounds by repositioning the upper left corner of a
+     * frame that is out of virtual device bounds to be within
+     * the bounds of the closest screen.
+     * 
+     * @param p		the location in question
+     * @return		the most ideal location, or the same point if
+     * 				that point is location within virtual device
+     * 				bounds.
+     */
+    private Point getValidLocationFor(Point p) {
+    	if(virtualDeviceBounds == null) {
+    		return p;
+    	}
+    	
+    	if(!virtualArea.contains(p)) {
+    		Rectangle r = getClosestDevice(p);
+    		p.x = Math.max(r.x, p.x);
+			p.x = Math.min((int)r.getMaxX(), p.x);
+			p.y = Math.max(r.y, p.y);
+			p.y = Math.min((int)r.getMaxY(), p.y);
+    	}
+    	return p;
+    }
+    
+    /**
+     * Called when the suggested location passed in by 
+     * the windowing environment (read Pivot) is outside
+     * the device bounds described by the combined graphics
+     * devices. This happens for sure with Mac OSX due to 
+     * the existence of the MenuBar on top.
+     * 
+     * @param p
+     * @return		the bounds of the closest screen relative 
+     * 				to the {@link Point} passed in.
+     */
+    private Rectangle getClosestDevice(Point p) {
+    	double distance = Integer.MAX_VALUE;
+    	Rectangle closest = null;
+    	for(Rectangle r : virtualDeviceBounds) {
+    		if(p.distance(r.getLocation()) < distance) {
+    			closest = r;
+    			distance = p.distance(r.getLocation());
+    		}
+    	}
+    	return closest;
+    }
+    
+    @Override
+    public void setLocation(int x, int y) {
+    	Point p = getValidLocationFor(new Point(x, y));
+    	super.setLocation(p.x, p.y);
+    }
+    
+    @Override
+    public void setLocation(Point p) {
+    	super.setLocation(getValidLocationFor(p));
+    }
+    
+    /**
+     * Sets the {@link TitleBar} component.
+     * @param c		the TitleBar component.
+     */
+    public void setTitleBar(TitleBar c) {
+        if(titlebarContainer == null) {
+            titlebarContainer = new JPanel(new BorderLayout());
+            super.add(titlebarContainer, BorderLayout.NORTH);
+        }
+        removeTitleBar();
+        this.titleBar = c;
+        titleBarHeight = c.getHeight();
+        titlebarContainer.add(c, BorderLayout.NORTH);
+    }
+    
+    /**
+     * Removes the {@link TitleBar} component
+     * @return	the removed TitleBar component.
+     */
+    public JComponent removeTitleBar() {
+        if(titlebarContainer == null) {
+            titlebarContainer = new JPanel(new BorderLayout());
+        }
+        if(titleBar != null) {
+            titlebarContainer.remove(titleBar);
+        }
+        JComponent c = titleBar;
+        this.titleBar = null;
+        setTitleBarHeight(0);
+        return c;
+    }
+    
+    /**
+     * Called by the SwingContainer class to determine the location
+     * to set on the delegate Window.
+     * @return
+     */
+    public java.awt.Insets getTitlebarInsets() {
+    	java.awt.Insets superInsets = super.getInsets();
+    	return new java.awt.Insets(
+    		titleBar.getPreferredSize().height, superInsets.left, 
+    			superInsets.bottom, superInsets.right);
+    }
+    
+    @Override
+    public void setJMenuBar(JMenuBar menuBar) {
+        this.menuBar = menuBar;
+        if(menuBar != null) {
+            titlebarContainer.add(menuBar, BorderLayout.SOUTH);
+        }
+    }
+    
+    @Override
+    public JMenuBar getJMenuBar() {
+        return menuBar;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setBorderColor(java.awt.Color)
+     */
+    public void setBorderColor(Color c) {
+        this.borderColor = c;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#getBorderColor()
+     */
+    public Color getBorderColor() {
+        return borderColor;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setBorderSize(int)
+     */
+    public void setBorderSize(int size) {
+        borderSize = size;
+        if(isDisplayable()) {
+            reshapeBorders();
+        }
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#getBorderSize()
+     */
+    public int getBorderSize() {
+        return borderSize;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setTitleBarHeight(int)
+     */
+    public void setTitleBarHeight(int height) {
+        titleBarHeight = height;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#getTitleBarHeight()
+     */
+    public int getTitleBarHeight() {
+        return titleBarHeight;
+    }
+    
+    @Override
+    public Container getContentPane() {
+        if(userPanel == null) {
+            return super.getContentPane();
+        }
+        return (Container)userPanel;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#add(java.awt.Component)
+     */
+    @Override
+    public Component add(Component comp) {
+        if(userPanel != null) {
+            mainContentPanel.remove(userPanel);
+        }
+        this.userPanel = comp;
+        mainContentPanel.add(userPanel, BorderLayout.CENTER);
+        return comp;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#add(java.lang.String, java.awt.Component)
+     */
+    @Override
+    public Component add(String s, Component comp) {
+        if(userPanel != null) {
+            mainContentPanel.remove(userPanel);
+        }
+        this.userPanel = comp;
+        mainContentPanel.add(userPanel, BorderLayout.CENTER);
+        return comp;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#add(java.awt.Component, int)
+     */
+    @Override
+    public Component add(Component comp, int index) {
+        if(userPanel != null) {
+            mainContentPanel.remove(userPanel);
+        }
+        this.userPanel = comp;
+        mainContentPanel.add(userPanel, BorderLayout.CENTER);
+        return comp;
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#add(java.awt.Component, java.lang.Object)
+     */
+    @Override
+    public void add(Component comp, Object constraints) {
+        if(mainContentPanel == null) {
+            super.add(comp, constraints);
+            return;
+        }
+        if(userPanel != null) {
+            mainContentPanel.remove(userPanel);
+        }
+        this.userPanel = comp;
+        mainContentPanel.add(userPanel, BorderLayout.CENTER);
+    }
+
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#add(java.awt.Component, java.lang.Object, int)
+     */
+    @Override
+    public void add(Component comp, Object constraints, int index) {
+        if(userPanel != null) {
+            mainContentPanel.remove(userPanel);
+        }
+        this.userPanel = comp;
+        mainContentPanel.add(userPanel, BorderLayout.CENTER);
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setLeftBorderComponent(javax.swing.JComponent)
+     */
+    public void setLeftBorderComponent(JComponent c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.leftBorderComponent = c;
+        mainContentPanel.add(leftBorderComponent, BorderLayout.WEST);
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setRightBorderComponent(javax.swing.JComponent)
+     */
+    public void setRightBorderComponent(JComponent c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.rightBorderComponent = c;
+        mainContentPanel.add(rightBorderComponent, BorderLayout.EAST);
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setBottomBorderComponent(javax.swing.JComponent)
+     */
+    public void setBottomBorderComponent(JComponent c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.bottomBorderComponent = c;
+        mainContentPanel.add(bottomBorderComponent, BorderLayout.SOUTH);
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setBorderDecorated(boolean, boolean)
+     */
+    public void setBorderDecorated(boolean b, boolean useDefaultBorders) {
+        this.isBorderDecorated = b;
+        if(useDefaultBorders) {
+            installDefaultBorders();
+        }
+    }
+    
+    /**
+     * Returns the bounding rectangle relative to screen coordinates.
+     * 
+     * @return  the bounding rectangle relative to screen coordinates.
+     */
+    public Rectangle getBoundsOnScreen() {
+        return getBounds();
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#pack()
+     */
+    @Override
+    public void pack() {
+        super.pack();
+        reshapeBorders();
+        addCursorHandler();
+    }
+    
+    /* (non-Javadoc)
+     * @see us.metaware.dtk.v2.DesktopWindow#setVisible(boolean)
+     */
+    @Override
+    public void setVisible(boolean b) {
+        super.setVisible(b);
+//        if(b && manager != null && !manager.isManagingWindow(this)) {
+//            manager.manageWindow(this);
+//        }
+    }
+    
+    public void setBounds(Rectangle r) {
+    	super.setBounds(r);
+    	if(isResizing) {
+    		mainContentPanel.setSize(r.getSize().width, r.getSize().height);
+    	}
+    }
+    
+    /**
+     * Initializes the border component sizes.
+     */
+    private void reshapeBorders() {
+        if(isBorderDecorated) {
+            if(leftBorderComponent != null) {
+                leftBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(rightBorderComponent != null) {
+                rightBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(bottomBorderComponent != null) {
+                bottomBorderComponent.setPreferredSize(new Dimension(getPreferredSize().width, borderSize));
+            }
+            mainContentPanel.revalidate();
+            mainContentPanel.repaint();
+        }
+    }
+    
+    /**
+     * Creates and returns the default title bar used if
+     * no user-specified title bar has been set.
+     * 
+     * @return  the default title bar
+     */
+    private TitleBar createTitleBar() {
+        TitleBar titleBar = new TitleBar(getTitle());
+        titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+        titleBar.setAlignmentX(Component.LEFT_ALIGNMENT);
+        
+        TitleBarControl control = createDefaultTitleBarControl();
+        control.setPreferredSize(new Dimension(24,20));
+        titleBar.addTitleBarControl(control);
+        
+        return titleBar; 
+    }
+    
+    /**
+     * Sets the title shown in this frame's titlebar.
+     * 
+     * @param	title	the frame's title
+     */
+    @Override
+    public void setTitle(String title) {
+        super.setTitle(title);
+        if(titleBar != null) {
+        	titleBar.setTitle(title);
+        }
+    }
+    
+    /**
+     * Adds the JPanel which houses the main content.
+     * 
+     * @param panel The JPanel which houses the main content.
+     */
+    private void addMainContentPanel(JPanel panel) {
+        this.mainContentPanel = panel;
+        this.mainContentPanel.setOpaque(true);
+        super.add(mainContentPanel, BorderLayout.CENTER);
+    }
+    
+   /**
+     * Creates and returns the panel which holds the main content.
+     * 
+     * @return  the panel which holds the main content.
+     */
+    private JPanel createMainContentPanel() {
+        return new JPanel(new BorderLayout()) {
+        	@Override
+        	public void paintChildren(Graphics g) {
+        		if(isResizing) {
+    	    		Rectangle r = g.getClipBounds();
+        	    	storedImage = new BufferedImage(r.width, r.height, BufferedImage.TYPE_INT_ARGB);
+        	    	Graphics2D g2 = (Graphics2D)storedImage.getGraphics();
+        	    	super.paintChildren(g2);
+        	    	g2.dispose();
+    	    	}
+        		super.paintChildren(g);
+        	}
+        	@Override
+        	public void paintComponent(Graphics g) {
+        		if(isDragging) {
+            		g.drawImage(storedImage,0,0,null);
+            	}else {
+        	    	super.paintComponent(g);
+            	}
+        	}
+        };
+    }
+    
+    /**
+     * Installs default border components.
+     */
+    private void installDefaultBorders() {
+        JComponent lBorder = new JPanel();
+        lBorder.setBackground(getBorderColor());
+        setLeftBorderComponent(lBorder);
+        
+        JComponent rBorder = new JPanel();
+        rBorder.setBackground(getBorderColor());
+        setRightBorderComponent(rBorder);
+        
+        JComponent bBorder = new JPanel();
+        bBorder.setBackground(getBorderColor());
+        setBottomBorderComponent(bBorder);
+    }
+    
+    private void addCursorHandler() {
+        cursorManager = new CursorManager();
+        titleBar.addMouseListener(cursorManager);
+        titleBar.addMouseMotionListener(cursorManager);
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(cursorManager);
+            leftBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(cursorManager);
+            rightBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(cursorManager);
+            bottomBorderComponent.addMouseMotionListener(cursorManager);
+        }
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
+    public void installManager(MouseHandler manager) {
+        titleBar.addMouseListener(manager);
+        titleBar.addMouseMotionListener(manager);
+        
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(manager);
+            leftBorderComponent.addMouseMotionListener(manager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(manager);
+            rightBorderComponent.addMouseMotionListener(manager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(manager);
+            bottomBorderComponent.addMouseMotionListener(manager);
+        }
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
+    public void uninstallManager(MouseHandler manager) {
+        titleBar.removeMouseListener(manager);
+        titleBar.removeMouseMotionListener(manager);
+        if(leftBorderComponent != null) {
+            leftBorderComponent.removeMouseListener(manager);
+            leftBorderComponent.removeMouseMotionListener(manager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.removeMouseListener(manager);
+            rightBorderComponent.removeMouseMotionListener(manager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.removeMouseListener(manager);
+            bottomBorderComponent.removeMouseMotionListener(manager);
+        }
+    }
+    
+    private void setCursorForSide(Side side) {
+        switch(side) {
+            case N : setCursor(Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR)); break;
+            case W : setCursor(Cursor.getPredefinedCursor(Cursor.W_RESIZE_CURSOR)); break;
+            case S : setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR)); break;
+            case E : setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR)); break;
+            case NW : setCursor(Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR)); break;
+            case NE : setCursor(Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR)); break;
+            case SW : setCursor(Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR)); break;
+            case SE : setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR)); break;
+            default : setCursor(Cursor.getDefaultCursor());
+        }
+    }
+    
+    class CursorManager extends MouseInputAdapter {
+        private boolean isPressed;
+        
+        public void mouseMoved(MouseEvent m) {
+            Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+            setCursorForSide(side);
+         }
+        
+        public void mouseExited(MouseEvent m) {
+            if(!isPressed) {
+            	setCursor(Cursor.getDefaultCursor());
+            }
+        }
+        
+        public void mousePressed(MouseEvent m) {
+            isPressed = true;
+            Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+            setCursorForSide(side);
+        }
+        
+        public void mouseReleased(MouseEvent m) {
+            isPressed = false;
+            setCursor(Cursor.getDefaultCursor());
+        }
+    }
+    
+    /**
+     * Returns a flag indicating whether this frame is set to
+     * be maximizable.
+     * @return  flag indicating whether this frame is set to
+     * be maximizable.
+     */
+    public boolean isMaximizable() {
+        return true;
+    }
+    
+    /**
+     * Returns a flag indicating whether this frame is set to
+     * be iconifiable.
+     * @return  flag indicating whether this frame is set to
+     * be iconifiable.
+     */
+    public boolean isIconifiable() {
+        return true;
+    }
+    
+    private TitleBarControl createDefaultTitleBarControl() {
+    	return new DefaultTitleBarControl();
+    }
+    
+    /**
+     * Used internally to denote the sides of this frame.
+     */
+    private enum Side {
+        N(0,-1), W(-1,0), S(0,1), E(1,0), NW(-1,-1), NE(1,-1), SW(-1,1), SE(1,1), NONE(0,0);
+        
+        private int h;
+        private int v;
+        
+        private Side(int horizontal, int vertical) {
+            this.h = horizontal;
+            this.v = vertical;
+        }
+        
+        public static Side sideFor(Rectangle r, Point p, int margin) {
+            int horiz = 0;
+            int vert = 0;
+            margin += 2;
+            if(p.x >= r.x && p.x <= r.x + margin) horiz = -1;
+            else if(p.x >= r.getMaxX() - margin && p.x <= r.getMaxX()) horiz = 1;
+            if(p.y >= r.y && p.y <= r.y + margin) vert = -1;
+            else if(p.y >= (r.getMaxY() - margin) && p.y <= r.getMaxY()) vert = 1;
+            
+            return sideFor(horiz, vert);
+        }
+        
+        public static Side sideFor(int horiz, int vert) {
+            for(Side s : values()) {
+                if(s.h == horiz && s.v == vert) return s;
+            }
+            return NONE;
+        }
+        
+        public int vertical() {
+        	return v;
+        }
+        
+        public int horizontal() {
+        	return h;
+        }
+    }
+    
+    /**
+     * Handles the mouse events to control frame dragging
+     */
+    class MouseHandler extends MouseAdapter implements MouseMotionListener {
+    	private Rectangle frameRect;
+    	private Point startPoint;
+    	private Side startSide;
+    	
+    	public MouseHandler() {
+    		
+    	}
+    	
+    	@Override
+    	public void mousePressed(MouseEvent m) {
+    		
+    		frameRect = getBounds();
+    		startPoint = MouseInfo.getPointerInfo().getLocation();
+    		startSide = Side.sideFor(getBounds(), startPoint, resizeMargin);
+    		
+    		if(titleBar.isControlHit(m)) {
+    			titleBar.mousePressed(m);
+    		}
+    	}
+    	
+    	public void mouseDragged(MouseEvent m) {
+    		isDragging = true;
+    		Point p = MouseInfo.getPointerInfo().getLocation();
+    		
+    		int xAmount = (p.x - startPoint.x);
+    		int yAmount = (p.y - startPoint.y);
+    		DesktopFrame.this.isResizing = !isMoveOp(startSide);
+    		Rectangle prev = frameRect;
+    		frameRect = DesktopFrame.this.isResizing ? 
+    			resizeRectangle(frameRect, startSide, xAmount, yAmount) :
+    				moveRectangle(frameRect, xAmount, yAmount);
+    			
+    		setBounds(frameRect);
+    		fireWindowDragged(prev.getLocation(), frameRect.getLocation());
+    		startPoint = p;
+    	}
+    	
+    	public void mouseReleased(MouseEvent m) {
+    		isDragging = false;
+    		if(titleBar.isControlHit(m)) {
+    			titleBar.mouseReleased(m);
+    		}
+    		
+    		fireDraggingStopped();
+    	}
+    	
+    	private Rectangle moveRectangle(Rectangle r, int xAmount, int yAmount) {
+    		Rectangle rect = new Rectangle(r);
+    		rect.setLocation(rect.x + xAmount, rect.y + yAmount);
+    		return rect;
+    	}
+    	
+    	private Rectangle resizeRectangle(Rectangle r, Side side, int deltaX, int deltaY) {
+    		Rectangle rect = new Rectangle(r);
+    		if(side.vertical() != 0 || side.horizontal() != 0) {
+    			if(side.vertical() == -1) {
+    				resizeTopTo(rect, r.y + deltaY);
+    			}else if(side.vertical() == 1) {
+    				resizeBottomTo(rect, (int)r.getMaxY() + deltaY);
+    			}
+    			
+    			if(side.horizontal() == -1) {
+    				resizeLeftTo(rect, r.x + deltaX);
+    			}else if(side.horizontal() == 1) {
+    				resizeRightTo(rect, (int)r.getMaxX() + deltaX);
+    			}
+    		}
+    		return rect;
+    	}
+    	
+    	private boolean isMoveOp(Side side) {
+    		return side == Side.NONE;
+    	}
+    	
+    	private void resizeLeftTo(Rectangle r, int x) {
+    		int sourceX = r.x;
+    		r.width -= (x - sourceX);
+    		r.x = x;
+    	}
+    	
+    	private void resizeRightTo(Rectangle r, int x) {
+    		int sourceX = (int)r.getMaxX();
+    		r.width += (x - sourceX);
+    	}
+    	
+    	private void resizeTopTo(Rectangle r, int y) {
+    		int sourceY = r.y;
+    		r.height -= (y - sourceY);
+    		r.y = y;
+    	}
+    	
+    	private void resizeBottomTo(Rectangle r, int y) {
+    		int sourceY = (int)r.getMaxY();
+    		r.height += (y - sourceY);
+    	}
+    }
+    
+    class DefaultTitleBarControl extends TitleBarControl {
+    	private double rotationAngle = 0.0d;
+    	private BufferedImage logo = createLogo(Color.DARK_GRAY, new Color(202, 202, 202));
+    	
+    	
+    	@Override
+    	public void paintComponent(Graphics g) {
+            super.paintComponent(g);
+            
+            Graphics2D g2 = (Graphics2D)g;
+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+            
+            int x = 2;
+            int y = 2;
+            int imgCenterX = x + this.logo.getWidth() / 2;
+            int imgCenterY = y + this.logo.getHeight() / 2 - 2;
+            g2.translate(imgCenterX, imgCenterY);
+            double angle = -getRotation();
+            g2.rotate(angle);
+            g2.translate(-imgCenterX, -imgCenterY);
+            g2.drawImage(this.logo, x, y, null); 
+        }
+    	
+    	private double getRotation() {
+    		return rotationAngle;
+    	}
+    	
+    	private BufferedImage createLogo(Color bg, Color fg) {
+    		BufferedImage img = new BufferedImage(20, 20, BufferedImage.TYPE_INT_ARGB);
+    		Graphics2D g2 = (Graphics2D)img.getGraphics();
+    		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+    		
+    		int lx = 0;
+    		g2.setColor(bg);
+            Arc2D lLogo = new Arc2D.Double(lx, 0, 16, 16, 90, 180, Arc2D.OPEN);
+            g2.draw(lLogo);
+            g2.drawLine(lx + 8, 0, lx + 8, 4);
+            g2.drawLine(lx + 8, 4, lx + 4, 4);
+            g2.drawLine(lx + 4, 4, lx + 4, 6);
+            g2.drawLine(lx + 4, 6, lx + 8, 6);
+            g2.drawLine(lx + 8, 6, lx + 8, 15);
+                    
+            Arc2D rLogo = new Arc2D.Double(lx + 2, 0, 18, 17, 90, -180, Arc2D.OPEN);
+            g2.fill(rLogo);
+            g2.setColor(fg);
+            g2.fillRect(lx + 10, 10, 4, 2);
+            
+            g2.dispose();
+            return img;
+    	}
+    	
+    	public void mousePressed(MouseEvent m) {
+    		if(isControlHit(m)) {
+    			rotationAngle = Math.PI;
+    			DefaultTitleBarControl.this.repaint();
+    		}
+    	}
+    	
+    	public void mouseReleased(MouseEvent m) {
+    		rotationAngle = 0;
+    		Rectangle r = getBounds();
+    		repaint(r.x, r.y, r.width, r.height);
+    	}
+    }
+    
+    public static interface DragListener {
+    	public void windowDragged(Point oldLoc, Point newLoc);
+    	public void draggingStopped();
+    }
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
new file mode 100644
index 0000000..ab51ee7
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
@@ -0,0 +1,110 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BasicStroke;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.LinearGradientPaint;
+import java.awt.Paint;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Stroke;
+import java.awt.event.MouseEvent;
+
+import javax.swing.JPanel;
+import javax.swing.SwingUtilities;
+
+@SuppressWarnings("serial")
+public class TitleBar extends JPanel implements java.awt.event.MouseListener {
+	public enum Location { LEFT, CENTER, RIGHT };
+	
+	private TitleBarControl control;
+	private String title;
+	
+	public TitleBar(String title) {
+		this.title = title;
+		setLayout(new BorderLayout());
+	}
+	
+	public boolean isControlHit(MouseEvent m) {
+		return control.isControlHit(m);
+	}
+	
+	public void setTitle(String title) {
+		this.title = title;
+	}
+	
+	@Override
+	public void mousePressed(MouseEvent m) {
+		control.mousePressed(m);
+	}
+	
+	@Override
+	public void mouseReleased(MouseEvent m) {
+		control.mouseReleased(m);
+	}
+	
+	//NO-OP
+	@Override public void mouseClicked(MouseEvent e) {}
+	@Override public void mouseEntered(MouseEvent e) {}
+	@Override public void mouseExited(MouseEvent e) {}
+	
+	
+	public void addTitleBarControl(TitleBarControl c) {
+		this.control = c;
+		switch(control.getControlLocation()) {
+			case LEFT: add(c, BorderLayout.WEST); break;
+			case CENTER: add(c, BorderLayout.CENTER); break;
+			case RIGHT : add(c, BorderLayout.EAST); break;
+		}
+	}
+	
+	@Override
+	public void paintComponent(Graphics g) {
+        super.paintComponent(g);
+        
+        Graphics2D g2 = (Graphics2D)g;
+        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        
+        fillTitleBar(g2);
+        
+        FontMetrics fm = g.getFontMetrics();
+        int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+        g2.setColor(Color.WHITE);
+        Rectangle r = g2.getClipBounds();
+        System.out.println("r.width = " + r + ", size = " + getSize());
+        int textX = (r.width - titleWidth) / 2;
+        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+        g2.drawString(title, textX + 1, textY + 1);
+        g2.setColor(Color.BLACK);
+        g2.drawString(title, textX, textY);
+    }
+	
+	private void fillTitleBar(Graphics2D g2) {
+		Paint oldPaint = g2.getPaint();
+        Stroke oldStroke = g2.getStroke();
+        
+        g2.setColor(new Color(241,241,241));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(0, 0, getWidth(), 0);
+        
+        LinearGradientPaint p = new LinearGradientPaint(
+        	1f, 1f, 1f, getHeight() - 1,
+        		new float[] { 0.0f, 0.499f, 0.5f, 1.0f },
+        			new Color[] { new Color(230, 230, 230), new Color(202, 202, 202),
+        				new Color(202, 202, 202), new Color(178, 178, 178) });
+        g2.setPaint(p);
+        g2.fillRect(0, 0, getWidth(), this.getHeight() - 1);
+        
+        
+        g2.setPaint(oldPaint);
+        g2.setColor(new Color(104, 104, 104));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(getX(), getHeight() - 1, getWidth(), getHeight() - 1);
+        
+        g2.setStroke(oldStroke);
+	}
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
new file mode 100644
index 0000000..1062fc9
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
@@ -0,0 +1,63 @@
+package org.apache.pivot.wtk;
+
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+import javax.swing.JComponent;
+
+
+
+/**
+ * Classes which are intended to provide titlebar control implementations 
+ * should be an extension of this class when used with the {@link DesktopFrame}
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public abstract class TitleBarControl extends JComponent implements MouseListener, MouseMotionListener {
+	private TitleBar.Location titleBarLoc = TitleBar.Location.LEFT;
+	
+	@Override
+	public void mouseDragged(MouseEvent e) {}
+
+	@Override
+	public void mouseMoved(MouseEvent e) {}
+
+	@Override
+	public void mouseClicked(MouseEvent e) {}
+
+	@Override
+	public void mousePressed(MouseEvent e) {}
+
+	@Override
+	public void mouseReleased(MouseEvent e) {}
+
+	@Override
+	public void mouseEntered(MouseEvent e) {}
+
+	@Override
+	public void mouseExited(MouseEvent e) {}
+	
+	/**
+	 * Sets the title bar location, see {@link TitleBar.Location}
+	 * 
+	 * @param loc
+	 */
+	public void setControlLocation(TitleBar.Location loc) {
+		if(loc == null) throw new NullPointerException("location can not be null");
+		this.titleBarLoc = loc;
+	}
+
+	/**
+	 * Returns the {@link TitleBar.Location}
+	 * @return	the {@link TitleBar.Location} of the control
+	 */
+	public TitleBar.Location getControlLocation() {
+		return this.titleBarLoc;
+	}
+	
+	public boolean isControlHit(MouseEvent e) {
+		return this.getBounds().contains(e.getPoint());
+	}
+}
