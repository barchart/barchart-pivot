diff --git a/pivot-wtk/src/org/apache/pivot/wtk/BarChartTitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/BarChartTitleBar.java
new file mode 100644
index 0000000..055d712
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/BarChartTitleBar.java
@@ -0,0 +1,466 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.LinearGradientPaint;
+import java.awt.MouseInfo;
+import java.awt.Paint;
+import java.awt.Polygon;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Stroke;
+import java.awt.Toolkit;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.event.WindowEvent;
+import java.awt.geom.Arc2D;
+import java.awt.geom.Area;
+import java.awt.geom.Point2D;
+import java.awt.image.BufferedImage;
+
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+import javax.swing.Timer;
+
+/**
+ * Component which represents the styling of the top border of
+ * a given frame. This {@link TitleBar} has the particular styling
+ * for a BarChart custom style. This title bar also defines a
+ * {@link TitleBarControl} which handles the minimize, maximize
+ * and close functions.
+ * 
+ * @author David Ray
+ *
+ */
+public class BarChartTitleBar extends TitleBar {
+
+	private static final long serialVersionUID = 8331424255756031127L;
+	
+	Timer t = null;
+	final String s = "A Mikey Mike Production";
+	int strLoc = Integer.MIN_VALUE;
+	int offset = 0;
+	boolean animating = false;
+	Timer repaintTimer = null;
+	
+	private DesktopFrame hostFrame;
+	
+	public BarChartTitleBar() {
+		addTitleBarControl(createTitleBarControl());
+		addSignature(createSignatureLogo());
+		getParentFrame();
+	}
+
+	@Override
+	protected void paintTitle(Graphics2D g2) {
+		g2.setFont(g2.getFont().deriveFont(Font.BOLD).deriveFont(16f));
+		FontMetrics fm = g2.getFontMetrics();
+		int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+        g2.setColor(Color.WHITE);
+        Rectangle r = g2.getClipBounds();
+        int textX = (r.width - titleWidth) / 2;
+        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+        g2.drawString(title, textX, textY);
+    }
+	
+	@Override
+	protected void fillTitleBar(Graphics2D g2) {
+		Paint oldPaint = g2.getPaint();
+        Stroke oldStroke = g2.getStroke();
+        
+        Rectangle r = g2.getClipBounds();
+        
+        g2.setColor(new Color(241,241,241));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(0, 0, getWidth(), 0);
+        
+        LinearGradientPaint lgp = new LinearGradientPaint(
+            new Point2D.Double(0,0), new Point2D.Double(0, r.height),
+            	new float[] {0.0f, 1.0f}, new Color[] { new Color(146, 173, 201), new Color(185, 209, 234) });
+        g2.setPaint(lgp);
+        g2.fillRect(0, 0, getWidth(), this.getHeight() - 1);
+        g2.setPaint(oldPaint);
+        
+        
+        g2.setPaint(oldPaint);
+        g2.setColor(new Color(104, 104, 104));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(getX(), getHeight() - 1, getWidth(), getHeight() - 1);
+        
+        g2.setStroke(oldStroke);
+        
+        if(animating) {
+        	g2.setClip(getBounds());
+        	g2.setColor(Color.WHITE);
+        	strLoc = - SwingUtilities.computeStringWidth(getFontMetrics(getFont()), s);
+        	g2.drawString(s, strLoc + offset, 20);
+        }
+	}
+	
+	private TitleBarControl createTitleBarControl() {
+		final BarChartTitleBarControl control = new BarChartTitleBarControl();
+		control.setPreferredSize(new Dimension(120,20));
+		control.setControlLocation(TitleBar.Location.RIGHT);
+		
+		repaintTimer = new Timer(250, new java.awt.event.ActionListener() {
+			public void actionPerformed(java.awt.event.ActionEvent e) {
+				java.awt.Point p = MouseInfo.getPointerInfo().getLocation();
+				SwingUtilities.convertPointFromScreen(p, control);
+				if(!minus.contains(p) && !plus.contains(p) && !close.contains(p)) {
+					overPlus = false;
+					overMinus = false;
+					overClose = false;
+					control.repaint();
+				}
+			}
+		});
+		repaintTimer.setRepeats(false);
+		
+		return control;
+	}
+	
+	private SignatureLogo createSignatureLogo() {
+		SignatureLogo logo = new SignatureLogo();
+		logo.setPreferredSize(new Dimension(60,20));
+		return logo;
+	}
+	
+	@SuppressWarnings("serial")
+	public class SignatureLogo extends java.awt.Component implements MouseListener, MouseMotionListener {
+		private double rotationAngle = 0.0d;
+		private BufferedImage logo = createLogo(Color.WHITE, new Color(95, 95, 95));
+		
+		public SignatureLogo() {
+			addMouseListener(this);
+			addMouseMotionListener(this);
+		}
+		
+		@Override
+		public void mouseDragged(MouseEvent e) {}
+
+		@Override
+		public void mouseMoved(MouseEvent e) {}
+
+		@Override
+		public void mouseClicked(MouseEvent e) {}
+
+		@Override
+		public void mouseEntered(MouseEvent e) {}
+
+		@Override
+		public void mouseExited(MouseEvent e) {}
+		
+		@Override
+		public void paint(Graphics g) {
+	        super.paint(g);
+	        
+	        Graphics2D g2 = (Graphics2D)g;
+	        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+	        
+	        int x = 5;
+	        int y = 6;
+	        int imgCenterX = x + this.logo.getWidth() / 2;
+	        int imgCenterY = y + this.logo.getHeight() / 2 - 2;
+	        g2.translate(imgCenterX, imgCenterY);
+	        double angle = -getRotation();
+	        g2.rotate(angle);
+	        g2.translate(-imgCenterX, -imgCenterY);
+	        g2.drawImage(this.logo, x, y, null); 
+	    }
+		
+		private double getRotation() {
+			return rotationAngle;
+		}
+		
+		private BufferedImage createLogo(Color bg, Color fg) {
+			BufferedImage img = new BufferedImage(20, 20, BufferedImage.TYPE_INT_ARGB);
+			Graphics2D g2 = (Graphics2D)img.getGraphics();
+			g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+			
+			int lx = 0;
+			g2.setColor(bg);
+	        Arc2D lLogo = new Arc2D.Double(lx, 0, 16, 16, 90, 180, Arc2D.OPEN);
+	        g2.draw(lLogo);
+	        g2.drawLine(lx + 8, 0, lx + 8, 4);
+	        g2.drawLine(lx + 8, 4, lx + 4, 4);
+	        g2.drawLine(lx + 4, 4, lx + 4, 6);
+	        g2.drawLine(lx + 4, 6, lx + 8, 6);
+	        g2.drawLine(lx + 8, 6, lx + 8, 15);
+	                
+	        Arc2D rLogo = new Arc2D.Double(lx + 2, 0, 18, 17, 90, -180, Arc2D.OPEN);
+	        g2.fill(rLogo);
+	        g2.setColor(new Color(149, 178, 207));
+	        g2.fillRect(lx + 10, 10, 4, 2);
+	        
+	        g2.dispose();
+	        return img;
+		}
+		
+		public void mousePressed(MouseEvent m) {
+			if(getBounds().contains(m.getPoint())) {
+				rotationAngle = Math.PI;
+				repaint();
+			}
+		}
+		
+		public void mouseReleased(MouseEvent m) {
+			rotationAngle = 0;
+			
+			if(m.getButton() == MouseEvent.BUTTON2 && (t == null || !t.isRunning())) {
+				t = new Timer(0, new java.awt.event.ActionListener() {
+					public void actionPerformed(java.awt.event.ActionEvent e) {
+						if(strLoc + offset > 69) {
+							t.stop();
+							t = null;
+							offset = strLoc;
+							animating = false;
+							BarChartTitleBar.this.repaint();
+						}else{
+							offset += 3;
+							BarChartTitleBar.this.repaint();
+						}
+					}
+				});
+				animating = true;
+				t.setRepeats(true);
+				t.setDelay(50);
+				t.start();
+			}
+			repaint();
+		}
+	}
+	
+	java.awt.Point mp = new java.awt.Point();
+	Rectangle minus = new Rectangle();
+	Rectangle plus = new Rectangle();
+	Rectangle close = new Rectangle();
+	boolean overClose = false;
+	boolean overPlus = false;
+	boolean overMinus = false;
+	@SuppressWarnings("serial")
+	public class BarChartTitleBarControl extends TitleBarControl {
+		public BarChartTitleBarControl() {
+			addMouseListener(this);
+			addMouseMotionListener(this);
+		}
+		public void update(Graphics g) {
+			paint(g);
+		}
+		public void paint(Graphics g) {
+			//super.paint(g);
+			System.out.println("paint debug 2");
+			
+			Graphics2D g2 = (Graphics2D)g;
+			Paint oldPaint = g2.getPaint();
+			g2.setColor(Color.white);
+			Rectangle r = g.getClipBounds();
+			r.height -= 1;
+			r.width -= 1;
+			
+			Rectangle xBox = new Rectangle(r.width - 43, 6, 31, 16);
+			close = xBox;
+			
+			g2.setColor(new Color(253, 228, 223));
+    		Rectangle innerBox = new Rectangle(r.width - 42, 7, 29, 14);
+    		g2.draw(innerBox);//252, 200, 191
+    		LinearGradientPaint topHalfX = new LinearGradientPaint(
+	            new Point2D.Double(r.width - 41, 8), new Point2D.Double(r.width - 41, 15),
+	            	new float[] {0.0f, 1.0f}, new Color[] { new Color(252, 200, 191), new Color(251, 168, 154) });
+    		g2.setPaint(topHalfX);
+    		g2.fill(new Rectangle(r.width - 41, 8, 28, 7));
+    		Color topColor = new Color(180, 63, 44);
+    		Color bottomColor = new Color(210, 126, 111);
+    		if(overClose) {
+    			topColor = new Color(215, 65, 22);
+    			bottomColor = new Color(245, 237, 108);
+    		}
+    		LinearGradientPaint bottomHalfX = new LinearGradientPaint(
+	            new Point2D.Double(r.width - 41, 14), new Point2D.Double(r.width - 41, 21),
+	            	new float[] {0.0f, 1.0f}, new Color[] { topColor, bottomColor });
+    		g2.setPaint(bottomHalfX);
+    		g2.fill(new Rectangle(r.width - 41, 14, 28, 7));
+    		g2.setPaint(oldPaint);
+			
+			int x = r.width - 98;
+			Area xfig = new Area(new Rectangle(x + 64, 10, 14, 8));
+    		int[] xpoints = new int[]{ x + 64, x + 68, x + 64 };
+    		int[] ypoints = new int[] { 10, 14, 18 };
+    		Polygon p = new Polygon(xpoints, ypoints, 3);
+    		Area leftTri = new Area(p);
+    		xfig.subtract(leftTri);
+    		xpoints = new int[]{ x + 68, x + 71, x + 74 };
+    		ypoints = new int[] { 10, 13, 10 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area topTri = new Area(p);
+    		xfig.subtract(topTri);
+    		xpoints = new int[]{ x + 78, x + 74, x + 78 };
+    		ypoints = new int[] { 10, 14, 18 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area rightTri = new Area(p);
+    		xfig.subtract(rightTri);
+    		xpoints = new int[]{ x + 68, x + 71, x + 74 };
+    		ypoints = new int[] { 18, 15, 18 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area bottomTri = new Area(p);
+    		xfig.subtract(bottomTri);
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.fill(xfig);
+    		g2.setColor(Color.BLACK);
+    		g2.draw(xfig);
+    		
+    		g2.draw(xBox);
+    		
+    		xBox = new Rectangle(r.width - 79, 6, 31, 16);
+    		plus = xBox;
+    		innerBox = new Rectangle(r.width - 78, 7, 29, 14);
+    		g2.setColor(new Color(223, 232, 242));
+    		g2.draw(innerBox);
+    		topColor = new Color(195, 212, 231);
+    		bottomColor = new Color(190, 211, 232);
+    		if(overPlus) {
+    			topColor = new Color(170, 213, 243);
+    			bottomColor = new Color(129, 192, 234);
+    		}
+    		topHalfX = new LinearGradientPaint(
+	            new Point2D.Double(r.width - 77, 8), new Point2D.Double(r.width - 77, 15),
+	            	new float[] {0.0f, 1.0f}, new Color[] { topColor,  bottomColor});
+    		g2.setPaint(topHalfX);
+    		g2.fill(new Rectangle(r.width - 77, 8, 28, 7));
+    		topColor = new Color(152, 177, 204);
+    		bottomColor = new Color(183, 208, 233);
+    		if(overPlus) {
+    			topColor = new Color(45, 115, 163);
+    			bottomColor = new Color(133, 239, 249);
+    		}
+    		bottomHalfX = new LinearGradientPaint(
+	            new Point2D.Double(r.width - 77, 14), new Point2D.Double(r.width - 77, 21),
+	            	new float[] {0.0f, 1.0f}, new Color[] { topColor, bottomColor });
+    		g2.setPaint(bottomHalfX);
+    		g2.fill(new Rectangle(r.width - 77, 14, 28, 7));
+    		g2.setColor(Color.WHITE);
+    		g2.setStroke(new BasicStroke(2));
+    		g2.drawRect(r.width - 69, 11, 12, 6);
+    		g2.setStroke(new BasicStroke(1));
+    		g2.setColor(Color.DARK_GRAY);
+    		g2.drawRect(r.width - 70, 10, 14, 8);
+    		g2.drawRect(r.width - 67, 13, 8, 2);
+    		g2.setColor(Color.BLACK);
+    		g2.draw(xBox);
+    		
+    		xBox = new Rectangle(r.width - 115, 6, 31, 16);
+    		minus = xBox;
+    		innerBox = new Rectangle(r.width - 114, 7, 29, 14);
+    		topColor = new Color(195, 212, 231);
+    		bottomColor = new Color(190, 211, 232);
+    		if(overMinus) {
+    			topColor = new Color(170, 213, 243);
+    			bottomColor = new Color(129, 192, 234);
+    		}
+    		topHalfX = new LinearGradientPaint(
+	            new Point2D.Double(r.width - 113, 8), new Point2D.Double(r.width - 113, 15),
+	            	new float[] {0.0f, 1.0f}, new Color[] { topColor, bottomColor });
+    		g2.setPaint(topHalfX);
+    		g2.fill(new Rectangle(r.width - 113, 8, 28, 7));
+    		topColor = new Color(152, 177, 204);
+    		bottomColor = new Color(183, 208, 233);
+    		if(overMinus) {
+    			topColor = new Color(45, 115, 163);
+    			bottomColor = new Color(133, 239, 249);
+    		}
+    		bottomHalfX = new LinearGradientPaint(
+	            new Point2D.Double(r.width - 113, 14), new Point2D.Double(r.width - 113, 21),
+	            	new float[] {0.0f, 1.0f}, new Color[] { topColor, bottomColor });
+    		g2.setPaint(bottomHalfX);
+    		g2.fill(new Rectangle(r.width - 113, 14, 28, 7));
+    		g2.setColor(new Color(223, 232, 242));
+    		g2.draw(innerBox);
+    		g2.setColor(Color.WHITE);
+    		g2.setStroke(new BasicStroke(2));
+    		g2.drawRect(r.width - 105, 13, 12, 2);
+    		g2.setStroke(new BasicStroke(1));
+    		g2.setColor(Color.DARK_GRAY);
+    		g2.drawRect(r.width - 106, 12, 14, 4);
+    		g2.setColor(Color.BLACK);
+    		g2.draw(xBox);
+    		
+		}
+		
+		@Override
+		public void mouseMoved(MouseEvent e) {
+			mp = e.getPoint();
+			if(plus.contains(e.getPoint())) {
+				overPlus = true;
+				overMinus = false;
+				overClose = false;
+			}else if(close.contains(e.getPoint())) {
+				overPlus = false;
+				overMinus = false;
+				overClose = true;
+			}else if(minus.contains(e.getPoint())) {
+				overPlus = false;
+				overMinus = true;
+				overClose = false;
+			}else{
+				overPlus = false;
+				overMinus = false;
+				overClose = false;
+			}
+			repaint();
+			
+			repaintTimer.restart();
+		}
+		
+		@Override
+		public void mouseReleased(MouseEvent e) {
+			if(minus.contains(e.getPoint())) {
+				fireFrameWillBecomeIconized();
+				hostFrame.setExtendedState(JFrame.ICONIFIED);
+			}else if(plus.contains(e.getPoint())) {
+				if((hostFrame.getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+					hostFrame.setExtendedState(JFrame.NORMAL);
+					hostFrame.setBordersVisible(true);
+					hostFrame.setBorderSize(2);
+					hostFrame.invalidate();
+					hostFrame.repaint();
+				}else{
+					hostFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
+					hostFrame.setBordersVisible(false);
+					hostFrame.setBorderSize(0);
+					hostFrame.invalidate();
+					hostFrame.repaint();
+				}
+			}else if(close.contains(e.getPoint())) {
+				WindowEvent wev = new WindowEvent(hostFrame, WindowEvent.WINDOW_CLOSING);
+                Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(wev);
+			}
+			
+			repaint();
+		}
+	}
+
+	private void getParentFrame() {
+		(new Thread() {
+			public void run() {
+				while(hostFrame == null) {
+    				try{ Thread.sleep(100); }catch(Exception e) { e.printStackTrace(); }
+    				SwingUtilities.invokeLater(new Runnable() {
+    					public void run() {
+    						hostFrame = (DesktopFrame)SwingUtilities.getAncestorOfClass(DesktopFrame.class, BarChartTitleBar.this);
+    						if((hostFrame.getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) { 
+    							hostFrame.setBorderSize(0);
+    						}
+    					}
+    				});
+				}
+			}
+		}).start();
+	}
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
index eb23b16..1f809ee 100644
--- a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
@@ -192,6 +192,26 @@ public final class DesktopApplicationContext extends ApplicationContext {
             }
         }
     }
+    
+    /**
+     * Returns an {@link EventEnabledFrame} if the java version is greater
+     * than or equal to 7. The returned frame is capable of painting its own
+     * title bar so that move events on the frame (normally not able to
+     * be received), can be dispatched.
+     * 
+     * @return	an instance of EventEnabledFrame
+     */
+    protected static HostFrame getHostFrame() {
+    	if(isRunningVersion7OrGreater() && isUsingCustomFrame()) {
+    		System.out.println("Running extended capability pivot fork.3");
+    		String style = System.getProperty("windowStyle");
+    		if(style != null) {
+    			return new DesktopFrame(DesktopFrame.Style.styleFor("BarChart"));
+    		}
+    		return new DesktopFrame(DesktopFrame.Style.styleFor("BarChart"));
+    	}
+    	return new HostFrame();
+    }
 
     // The AWT Window class does not define a title property; this interface allows
     // the HostFrame and HostDialog titles to be handled polymorphically
@@ -201,11 +221,13 @@ public final class DesktopApplicationContext extends ApplicationContext {
     }
 
     // Native host frame
-    private static class HostFrame extends java.awt.Frame implements TitledWindow {
+    // David Ray : Forked change of access level (from private to protected) to this class and its extention
+    //			  to javax.swing.JFrame from java.awt.Frame
+    public static class HostFrame extends java.awt.Frame implements TitledWindow {
         private static final long serialVersionUID = 5340356674429280196L;
 
         public HostFrame() {
-            enableEvents(AWTEvent.WINDOW_EVENT_MASK
+        	enableEvents(AWTEvent.WINDOW_EVENT_MASK
                 | AWTEvent.WINDOW_STATE_EVENT_MASK);
 
             // Disable focus traversal keys
@@ -280,7 +302,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
     }
 
     // Native host dialog for secondary displays
-    private static class HostDialog extends java.awt.Dialog implements TitledWindow {
+    private static class HostDialog extends java.awt.Frame implements TitledWindow {
         private static final long serialVersionUID = 5340356674429280196L;
 
         private DisplayHost displayHost = new DesktopDisplayHost();
@@ -288,10 +310,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         private DisplayListener displayCloseListener;
 
         public HostDialog(java.awt.Window owner, boolean modal, DisplayListener displayCloseListener) {
-            super(owner, modal ?
-                java.awt.Dialog.ModalityType.APPLICATION_MODAL : java.awt.Dialog.ModalityType.MODELESS);
-
-            this.displayCloseListener = displayCloseListener;
+        	this.displayCloseListener = displayCloseListener;
 
             enableEvents(AWTEvent.WINDOW_EVENT_MASK);
 
@@ -479,7 +498,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         boolean center = false;
         boolean resizable = true;
         boolean maximized = false;
-        boolean undecorated = false;
+        boolean undecorated = isRunningVersion7OrGreater() && isUsingCustomFrame();
         boolean fullScreen = false;
         boolean preserveSplashScreen = false;
 
@@ -564,7 +583,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         displays.add(primaryDisplayHost.getDisplay());
 
         // Create the windowed host frame
-        windowedHostFrame = new HostFrame();
+        windowedHostFrame = getHostFrame();
         windowedHostFrame.add(primaryDisplayHost);
         windowedHostFrame.setUndecorated(undecorated);
 
@@ -647,6 +666,28 @@ public final class DesktopApplicationContext extends ApplicationContext {
             });
         }
     }
+    
+    /**
+     * Called from the declaration of "undecorated" which calls
+     * {@link #isRunningVersion7OrGreater()} to determine if it is
+     * safe to create a custom barchart frame.
+     * 
+     * @return	flag indicating whether the java version is >= 1.7
+     */
+    private static boolean isRunningVersion7OrGreater() {
+    	String version = System.getProperty("java.version");
+    	return Integer.parseInt(version.split("\\.")[1]) >= 7;
+    }
+    
+    /**
+     * Returns a flag indicating whether the custom frame property was
+     * set to true on the command line
+     * @return	flag indicating the wish to use the custom frame
+     */
+    private static boolean isUsingCustomFrame() {
+    	String customProp = System.getProperty("requireCustomFrame");
+    	return customProp != null && customProp.trim().equalsIgnoreCase("true");
+    }
 
     private static void initializeOSExtensions() {
         String osName = System.getProperty("os.name");
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
new file mode 100644
index 0000000..1936231
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
@@ -0,0 +1,1184 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BasicStroke;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Cursor;
+import java.awt.Dimension;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.MouseInfo;
+import java.awt.Panel;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Toolkit;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.geom.Area;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+
+
+
+/**
+ * Sub-class of {@link DesktopApplicationContext.HostFrame} which supports custom frame movement
+ * functionality
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public class DesktopFrame extends DesktopApplicationContext.HostFrame {
+	public enum Style { 
+		NATIVE_OSX, NATIVE_WIN, NATIVE_LINUX, CUSTOM, DEFAULT, BARCHART;
+		
+		public void apply(DesktopFrame frame) {
+			frame.configuredStyle = this;
+			
+			switch(frame.configuredStyle) {
+		        case NATIVE_LINUX:
+		        case NATIVE_WIN: {
+		        	frame.titleBarHeight = WIN_TITLEBAR_HEIGHT;
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		        	
+		        	frame.setBorderColor(Color.GRAY);
+		            frame.setBorderDecorated(true, true);
+		            frame.setBorderSize(5);
+		            
+		            frame.installWindowsBorders();
+		            
+		        	frame.reshapeBorders();
+		        	frame.mainContentPanel.invalidate();
+		        	break;
+		        }
+		        case NATIVE_OSX: {
+		        	frame.titleBarHeight = OSX_TITLEBAR_HEIGHT;
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		            frame.setBorderDecorated(true, true);
+		            frame.setBorderSize(1);
+		            frame.reshapeBorders();
+		        	break;
+		        }
+		        case CUSTOM: {
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		            frame.setBorderDecorated(true, true);
+		            frame.setBorderSize(1);
+		            frame.reshapeBorders();
+		        	break;
+		        }
+		        case BARCHART: {
+		        	frame.titleBarHeight = WIN_TITLEBAR_HEIGHT;
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		            frame.setBorderDecorated(true, true);
+		            frame.setBorderSize(2);
+		            frame.reshapeBorders();
+		        	break;
+		        }
+		        default: {
+		        	frame.titleBarHeight = DEFAULT_TITLEBAR_HEIGHT;
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		            frame.setBorderDecorated(true, true);
+		            break;
+		        }
+	        }
+			
+			if(frame.titleBar != null) {
+				frame.addCursorHandler();
+		        frame.installMouseHandler(frame.new MouseHandler());
+		        TitleBarControl tbc =  frame.titleBar.getTitleBarControl();
+		        if(tbc != null) {
+		        	frame.titleBar.invalidate();
+		        	tbc.invalidate();
+		        	tbc.repaint();
+		        }
+		       
+		        frame.repaint();
+			}
+		}
+		
+		public static Style styleFor(String styleString) {
+			if(styleString == null) {
+				return null;
+			}
+			if(styleString.equalsIgnoreCase("osx")) {
+				return Style.NATIVE_OSX;
+			}else if(styleString.toLowerCase().indexOf("win") != -1) {
+				return Style.NATIVE_WIN;
+			}else if(styleString.equalsIgnoreCase("linux")) {
+				return Style.NATIVE_LINUX;
+			}else if(styleString.toLowerCase().indexOf("bar") != -1) {
+				return Style.BARCHART;
+			}
+			return null;
+		}
+	};
+	private static final int OSX_TITLEBAR_HEIGHT = 22;
+	private static final int WIN_TITLEBAR_HEIGHT = 30;
+	private static final int DEFAULT_TITLEBAR_HEIGHT = 25;
+	private static boolean NATIVE_STYLE_OVERRIDE;
+	
+	/** The size in pixels of the border */
+    private int borderSize = 1;
+    /** The thickness over which a cursor change will be triggered for resizing */
+    private int resizeMargin = borderSize;
+    /** The default height of the title bar */
+    private int titleBarHeight;
+    /** The Component shown as the title bar decoration */
+    private TitleBar titleBar;
+    /** The border color */
+    private Color borderColor = new Color(120, 120, 120);
+    /** Flag indicating this frame contains borders. */
+    private boolean isBorderDecorated;
+    /** Enum which handles the native os look and feel configuration */
+    private Style configuredStyle;
+    /** Flag indicating a resize operation ocurring */
+    private boolean isResizing;
+    /** Handles cursor changes to indicated resizing */
+    private CursorManager cursorManager;
+    /** The left border component which detects mouse events for cursor manipulation and resizing */
+    private Component leftBorderComponent;
+    /** The right border component which detects mouse events for cursor manipulation and resizing */
+    private Component rightBorderComponent;
+    /** The bottom border component which detects mouse events for cursor manipulation and resizing */
+    private Component bottomBorderComponent;
+    /** Houses the component added to this frame by the user */
+    private Container mainContentPanel;
+    /** List of listeners with interest in drag notifications */
+    private List<DragListener> dragListeners = new ArrayList<DragListener>();
+    /** List of screen rectangles - one per monitor */
+    private List<Rectangle> virtualDeviceBounds;
+    /** The shape of the virtual screens */
+    private Area virtualArea;
+    
+	
+	public DesktopFrame() {
+		this(NATIVE_STYLE_OVERRIDE ? Style.CUSTOM : getNativeStyle());
+	}
+	
+	public DesktopFrame(Style style) {
+		setUndecorated(true);
+		
+		setLayout(new BorderLayout());
+		
+		Panel panel = createMainContentPanel();
+		addMainContentPanel(panel);
+		
+		style.apply(this);
+		
+		//Collect the current monitor configuration boundaries.
+        getEnvironmentInfo(); 
+	}
+	
+	@Override
+	public Component add(Component comp) {
+		mainContentPanel.add(comp, BorderLayout.CENTER);
+		return comp;
+	}
+	
+	@Override
+	public void update(Graphics g) {
+		paint(g);
+	}
+	
+	/**
+     * Protects against a frame location being out of aggregate
+     * device bounds by repositioning the upper left corner of a
+     * frame that is out of virtual device bounds to be within
+     * the bounds of the closest screen.
+     * 
+     * @param p		the location in question
+     * @return		the most ideal location, or the same point if
+     * 				that point is location within virtual device
+     * 				bounds.
+     */
+    private Point getValidLocationFor(Point p) {
+    	if(virtualDeviceBounds == null) {
+    		return p;
+    	}
+    	
+    	if(!virtualArea.contains(p)) {
+    		Rectangle r = getClosestDevice(p);
+    		p.x = Math.max(r.x, p.x);
+			p.x = Math.min((int)r.getMaxX(), p.x);
+			p.y = Math.max(r.y, p.y);
+			p.y = Math.min((int)r.getMaxY(), p.y);
+    	}
+    	return p;
+    }
+    
+    /**
+     * Called when the suggested location passed in by 
+     * the windowing environment (read Pivot) is outside
+     * the device bounds described by the combined graphics
+     * devices. This happens for sure with Mac OSX due to 
+     * the existence of the MenuBar on top.
+     * 
+     * @param p
+     * @return		the bounds of the closest screen relative 
+     * 				to the {@link Point} passed in.
+     */
+    private Rectangle getClosestDevice(Point p) {
+    	double distance = Integer.MAX_VALUE;
+    	Rectangle closest = null;
+    	for(Rectangle r : virtualDeviceBounds) {
+    		if(p.distance(r.getLocation()) < distance) {
+    			closest = r;
+    			distance = p.distance(r.getLocation());
+    		}
+    	}
+    	return closest;
+    }
+	
+	/**
+     * Sets the location of this {@link TempFrame}
+     * 
+     * Native frames would know their screen bounds, but 
+     * because this is a custom frame, we must intercept this
+     * call to make sure that the location is a valid one.
+     * 
+     * @param	x	x location
+     * @param	y   y location
+     * 
+     */
+    @Override
+    public void setLocation(int x, int y) {
+    	Point p = getValidLocationFor(new Point(x, y));
+    	super.setLocation(p.x, p.y);
+    }
+    
+    /**
+     * Sets the location of this {@link TempFrame}
+     * 
+     * Native frames would know their screen bounds, but 
+     * because this is a custom frame, we must intercept this
+     * call to make sure that the location is a valid one.
+     * 
+     * @param	p	the location of this frame as a {@link Point}
+     */
+    @Override
+    public void setLocation(Point p) {
+    	super.setLocation(getValidLocationFor(p));
+    }
+	
+	/**
+     * Returns the current component serving as the {@link TitleBar}
+     * 
+     * @return	the current component serving as the {@link TitleBar}
+     */
+    public TitleBar getTitleBar() {
+    	return this.titleBar;
+    }
+    
+    /**
+     * Sets the {@link TitleBar} component.
+     * 
+     * The {@code TitleBar}'s preferred height must be set prior
+     * to calling this method (preferredWidth is irrelevant, i.e.
+     * can be set to zero).
+     * 
+     * @param c		the TitleBar component.
+     */
+    public void setTitleBar(TitleBar c) {
+    	removeTitleBar();
+        this.titleBar = c;
+        titleBarHeight = c.getPreferredSize().height;
+        add(c, BorderLayout.NORTH);
+        invalidate();
+        validate();
+        repaint();
+        titleBar.repaint();
+    }
+	
+	/**
+     * Called by the SwingContainer class to determine the location
+     * to set on the delegate Window.
+     * @return
+     */
+    public java.awt.Insets getTitlebarInsets() {
+    	java.awt.Insets superInsets = super.getInsets();
+    	if(titleBar == null) {
+    		return superInsets;
+    	}
+    	return new java.awt.Insets(
+    		titleBar.getPreferredSize().height, superInsets.left + leftBorderComponent.getWidth(), 
+    			superInsets.bottom + bottomBorderComponent.getHeight(), superInsets.right + rightBorderComponent.getWidth());
+    }
+	
+	/**
+     * Installs the handler which controls the cursor changes
+     * for border or titlebar mouse overs.
+     */
+    private void addCursorHandler() {
+    	if(cursorHandlerInstalled() || titleBar == null) return;
+    	
+    	cursorManager = new CursorManager();
+        titleBar.addMouseListener(cursorManager);
+        titleBar.addMouseMotionListener(cursorManager);
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(cursorManager);
+            leftBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(cursorManager);
+            rightBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(cursorManager);
+            bottomBorderComponent.addMouseMotionListener(cursorManager);
+        }
+    }
+    
+    /**
+     * Installs the main mouse controller which handles the frame movement, etc.
+     * @param manager	
+     */
+    public void installMouseHandler(MouseHandler manager) {
+        titleBar.addMouseListener(manager);
+        titleBar.addMouseMotionListener(manager);
+        
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(manager);
+            leftBorderComponent.addMouseMotionListener(manager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(manager);
+            rightBorderComponent.addMouseMotionListener(manager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(manager);
+            bottomBorderComponent.addMouseMotionListener(manager);
+        }
+    }
+    
+    /**
+     * Checks for the prior installation of the {@link TempFrame.CursorManager}.
+     * 
+     * @return	true if already installed, false if not.
+     */
+    private boolean cursorHandlerInstalled() {
+    	if(titleBar != null) {
+	    	MouseListener[] installedListeners = titleBar.getMouseListeners();
+	    	for(MouseListener l : installedListeners) {
+	    		if(l instanceof CursorManager) {
+	    			return true;
+	    		}
+	    	}
+    	}
+    	return false;
+    }
+    
+    /**
+     * Adds the JPanel which houses the main content.
+     * 
+     * @param panel The JPanel which houses the main content.
+     */
+    private void addMainContentPanel(Panel panel) {
+        this.mainContentPanel = panel;
+        super.add(mainContentPanel, BorderLayout.CENTER);
+    }
+    
+   /**
+     * Creates and returns the panel which holds the main content.
+     * 
+     * @return  the panel which holds the main content.
+     */
+    private Panel createMainContentPanel() {
+        Panel main = new Panel() {
+        	@Override
+        	public void update(Graphics g) {
+        		paint(g);
+        	}
+        };
+       
+        main.setPreferredSize(new Dimension(300, 200));
+        main.setLayout(new BorderLayout());
+        return main;
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#WEST})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setLeftBorderComponent(Component c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.leftBorderComponent = c;
+        mainContentPanel.add(leftBorderComponent, BorderLayout.WEST);
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#EAST})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setRightBorderComponent(Component c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.rightBorderComponent = c;
+        mainContentPanel.add(rightBorderComponent, BorderLayout.EAST);
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#SOUTH})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setBottomBorderComponent(Component c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.bottomBorderComponent = c;
+        mainContentPanel.add(bottomBorderComponent, BorderLayout.SOUTH);
+    }
+    
+    /**
+     * Checks the os system property for the current os and
+     * returns an enum specifying a style for that particular
+     * os.
+     * 
+     * @return	{@link Style}
+     */
+    private static Style getNativeStyle() {
+    	String osName = System.getProperty("os.name");
+
+        if (osName.toLowerCase(Locale.ENGLISH).startsWith("mac os x")) {
+        	return Style.NATIVE_OSX;
+        }else if(osName.toLowerCase(Locale.ENGLISH).startsWith("window")) {
+        	return Style.NATIVE_WIN;
+        }else if(osName.toLowerCase(Locale.ENGLISH).startsWith("linux")) {
+        	return Style.NATIVE_LINUX;
+        }
+        return Style.DEFAULT;
+    }
+	
+	/**
+     * If a custom style (i.e. non-native prebuilt style) is desired
+     * this method must be called with "true" before this frame
+     * is instantiated.
+     * 
+     * @param b
+     */
+    public static void overrideNativeStyle(boolean b) {
+    	DesktopFrame.NATIVE_STYLE_OVERRIDE = b;
+    }
+	
+	/**
+     * Returns a flag indicating whether this frame is set to
+     * be maximizable.
+     * @return  flag indicating whether this frame is set to
+     * be maximizable.
+     */
+    public boolean isMaximizable() {
+        return true;
+    }
+    
+    /**
+     * Returns a flag indicating whether this frame is set to
+     * be iconifiable.
+     * @return  flag indicating whether this frame is set to
+     * be iconifiable.
+     */
+    public boolean isIconifiable() {
+        return true;
+    }
+    
+    /**
+     * Sets the flag indicating whether borders should be painted around this frame.
+     * Additionally, the user may also specify whether the default borders should 
+     * be installed.
+     * 
+     * @param b						border decorated flag.
+     * @param useDefaultBorders		flag indicating the desire to use the default 
+     * 								borders.
+     */
+    public void setBorderDecorated(boolean b, boolean useDefaultBorders) {
+        this.isBorderDecorated = b;
+        if(useDefaultBorders) {
+            installDefaultBorders();
+        }
+    }
+    
+    /**
+     * Installs default border components.
+     */
+    private void installDefaultBorders() {
+        Panel lBorder = new Panel();
+        lBorder.setBackground(getBorderColor());
+        setLeftBorderComponent(lBorder);
+        
+        Panel rBorder = new Panel();
+        rBorder.setBackground(getBorderColor());
+        setRightBorderComponent(rBorder);
+        
+        Panel bBorder = new Panel();
+        bBorder.setBackground(getBorderColor());
+        setBottomBorderComponent(bBorder);
+    }
+    
+    /**
+     * Called from {@link Style#apply(TempFrame)} to
+     * install native Windows os look and feel to this
+     * frame.
+     */
+    private void installWindowsBorders() {
+    	removeBorders();
+    	
+    	Component lBorder = new Panel() {
+    		@Override
+    		public void paint(Graphics g) {
+    			super.paint(g);
+    			Rectangle r = g.getClipBounds();
+    			g.setColor(getBorderColor());
+    			g.fillRect(r.x, r.y, r.width, r.height);
+    			g.setColor(Color.WHITE);
+        		g.drawLine(1,0,1,r.height);
+    		}
+    		@Override
+    		public void update(Graphics g) {
+    			paint(g);
+    		}
+    	};
+        lBorder.setBackground(getBorderColor());
+    	setLeftBorderComponent(lBorder);
+        
+        Component rBorder = new Panel() {
+        	public void paint(Graphics g) {
+        		super.paint(g);
+        		Rectangle r = g.getClipBounds();
+        		g.setColor(getBorderColor());
+    			g.fillRect(r.x, r.y, r.width, r.height);
+        		g.setColor(Color.WHITE);
+        		g.drawLine(r.width - 2,0,r.width - 2,r.height - 1);
+        	}
+        	@Override
+        	public void update(Graphics g) {
+        		paint(g);
+        	}
+        };
+        rBorder.setBackground(getBorderColor());
+        setRightBorderComponent(rBorder);
+        
+        Component bBorder = new Panel() {
+        	@Override
+        	public void paint(Graphics g) {
+        		super.paint(g);
+        		Rectangle r = g.getClipBounds();
+        		g.setColor(getBorderColor());
+    			g.fillRect(r.x, r.y, r.width, r.height);
+        		g.setColor(Color.WHITE);
+        		g.drawLine(1,r.height - 2,r.width - 2,r.height - 2);
+        		g.drawLine(1, 0, 1, r.height - 2);
+        		g.drawLine(r.width - 2, 0, r.width - 2, r.height - 2);
+        	}
+        	@Override
+        	public void update(Graphics g) {
+        		paint(g);
+        	}
+        };
+        bBorder.setBackground(getBorderColor());
+        setBottomBorderComponent(bBorder);
+    }
+    
+    /**
+     * Removes the border components.
+     */
+    private void removeBorders() {
+    	removeBorderCursorHandlers();
+    	if(leftBorderComponent != null) {
+    		((Container)mainContentPanel).remove(leftBorderComponent);
+    		leftBorderComponent = null;
+    	}
+    	if(rightBorderComponent != null) {
+    		((Container)mainContentPanel).remove(rightBorderComponent);
+    		rightBorderComponent = null;
+    	}
+    	if(bottomBorderComponent != null) {
+    		((Container)mainContentPanel).remove(bottomBorderComponent);
+    		bottomBorderComponent = null;
+    	}
+    }
+    
+    /**
+     * Uninstalls the handler which manages cursors over the borders.
+     */
+    private void removeBorderCursorHandlers() {
+    	if(leftBorderComponent != null) {
+            leftBorderComponent.removeMouseListener(cursorManager);
+            leftBorderComponent.removeMouseMotionListener(cursorManager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.removeMouseListener(cursorManager);
+            rightBorderComponent.removeMouseMotionListener(cursorManager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.removeMouseListener(cursorManager);
+            bottomBorderComponent.removeMouseMotionListener(cursorManager);
+        }
+    }
+    
+    /**
+     * Sets the color that will be used to paint the border.
+     * @param c		the border color
+     */
+    public void setBorderColor(Color c) {
+        this.borderColor = c;
+    }
+    
+    /**
+     * Returns the color that is used to paint the border
+     * @return	the current border color
+     */
+    public Color getBorderColor() {
+        return borderColor;
+    }
+    
+    /**
+     * Sets the size in pixels of the frame border
+     * 
+     * @param size	the frame border size.
+     */
+    public void setBorderSize(int size) {
+        borderSize = size;
+        if(isDisplayable()) {
+            reshapeBorders();
+        }
+    }
+    
+    /**
+     * Returns the border size.
+     * @return	the border size.
+     */
+    public int getBorderSize() {
+        return borderSize;
+    }
+    
+    /**
+     * Initializes the border component sizes.
+     */
+    private void reshapeBorders() {
+        if(isBorderDecorated) {
+            if(leftBorderComponent != null) {
+                leftBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(rightBorderComponent != null) {
+                rightBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(bottomBorderComponent != null) {
+                bottomBorderComponent.setPreferredSize(new Dimension(getPreferredSize().width, borderSize));
+            }
+            invalidate();
+            repaint();
+        }
+    }
+    
+    /**
+     * Removes or installs the size of the border as
+     * to render it visible/invisible
+     */
+    public void setBordersVisible(boolean visible) {
+    	leftBorderComponent.setVisible(visible);
+    	rightBorderComponent.setVisible(visible);
+    	bottomBorderComponent.setVisible(visible);
+    }
+    
+    /**
+     * Sets the height in pixels of the title bar.
+     * 
+     * @param height	the height of the title bar
+     */
+    public void setTitleBarHeight(int height) {
+        titleBarHeight = height;
+    }
+    
+    /**
+     * Returns the title bar height
+     * 
+     * @return	the current title bar height
+     */
+    public int getTitleBarHeight() {
+        return titleBarHeight;
+    }
+    
+    /**
+     * Creates and returns the default title bar used if
+     * no user-specified title bar has been set.
+     * 
+     * @return  the default title bar
+     */
+    private TitleBar createTitleBar(Style style) {
+    	TitleBar titleBar = null;
+    	switch(style) {
+	    	case NATIVE_LINUX:
+	    	case NATIVE_WIN: {
+	    		titleBar = new WindowsTitleBar();
+	    		titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+	            break;
+	    	}
+	    	case NATIVE_OSX: {
+	    		titleBar = new OSXTitleBar();
+	    		titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+	            break;
+	    	}
+	    	case CUSTOM: {
+	    		break;
+	    	}
+	    	case BARCHART: {
+	    		titleBar = new BarChartTitleBar();
+	    		titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+	            break;
+	    	}
+	    	default: {
+	    		titleBar = new DefaultTitleBar();
+	    		titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+	            TitleBarControl control = createDefaultTitleBarControl();
+	            control.setPreferredSize(new Dimension(60,20));
+	            titleBar.addTitleBarControl(control);
+	            break;
+	    	}
+    	}
+    	
+    	return titleBar; 
+    }
+    
+    /**
+     * Creates the default title bar buttons.
+     * @return	the default title bar buttons.
+     */
+    private TitleBarControl createDefaultTitleBarControl() {
+    	return new DefaultTitleBarControl();
+    }
+    
+    /**
+     * Sets the title shown in this frame's titlebar.
+     * 
+     * @param	title	the frame's title
+     */
+    @Override
+    public void setTitle(String title) {
+        super.setTitle(title);
+        if(titleBar != null) {
+        	titleBar.setTitle(title);
+        	titleBar.repaint();
+        }
+    }
+    
+    /**
+     * Removes the {@link TitleBar} component
+     */
+    public void removeTitleBar() {
+       Component c = titleBar;
+        if(c != null) {
+        	remove(c);
+        }
+        
+        this.titleBar = null;
+        setTitleBarHeight(0);
+        invalidate();
+        validate();
+        repaint();
+    }
+	
+	/**
+     * Used internally to denote the sides of this frame.
+     */
+    private enum Side {
+        N(0,-1), W(-1,0), S(0,1), E(1,0), NW(-1,-1), NE(1,-1), SW(-1,1), SE(1,1), NONE(0,0);
+        
+        private int h;
+        private int v;
+        
+        private Side(int horizontal, int vertical) {
+            this.h = horizontal;
+            this.v = vertical;
+        }
+        
+        public static Side sideFor(Rectangle r, Point p, int margin) {
+            int horiz = 0;
+            int vert = 0;
+            margin += 2;
+            if(p.x >= r.x && p.x <= r.x + margin) horiz = -1;
+            else if(p.x >= r.getMaxX() - margin && p.x <= r.getMaxX()) horiz = 1;
+            if(p.y >= r.y && p.y <= r.y + margin) vert = -1;
+            else if(p.y >= (r.getMaxY() - margin) && p.y <= r.getMaxY()) vert = 1;
+            
+            return sideFor(horiz, vert);
+        }
+        
+        public static Side sideFor(int horiz, int vert) {
+            for(Side s : values()) {
+                if(s.h == horiz && s.v == vert) return s;
+            }
+            return NONE;
+        }
+        
+        public int vertical() {
+        	return v;
+        }
+        
+        public int horizontal() {
+        	return h;
+        }
+    }
+    
+    /**
+     * Dynamically alters the cursor being displayed depending on the
+     * current mouse location.
+     * 
+     * @param side
+     */
+    private void setCursorForSide(Side side) {
+        switch(side) {
+            case N : setCursor(Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR)); break;
+            case W : setCursor(Cursor.getPredefinedCursor(Cursor.W_RESIZE_CURSOR)); break;
+            case S : setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR)); break;
+            case E : setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR)); break;
+            case NW : setCursor(Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR)); break;
+            case NE : setCursor(Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR)); break;
+            case SW : setCursor(Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR)); break;
+            case SE : setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR)); break;
+            default : setCursor(Cursor.getDefaultCursor());
+        }
+    }
+    
+    /**
+     * Adds the specified {@link DragListener} to this {@code DesktopFrame}
+     * @param d		the {@code DragListener} to add.
+     */
+    public void addDragListener(DragListener d) {
+    	if(d != null) {
+    		dragListeners.add(d);
+    	}
+    }
+    
+    /**
+     * Removes the specified {@link DragListener}
+     * @param d
+     */
+    public void removeDragListener(DragListener d) {
+    	dragListeners.remove(d);
+    }
+    
+    /**
+     * Fires a window dragged event to registered listeners.
+     * 
+     * @param oldLoc
+     * @param newLoc
+     */
+    public void fireWindowDragged(Point oldLoc, Point newLoc) {
+    	for(DragListener l : dragListeners) {
+    		l.windowDragged(oldLoc, newLoc);
+    	}
+    }
+    
+    /**
+     * Fires an event notifiying {@link DragListener}s that
+     * dragging has stopped.
+     */
+    public void fireDraggingStopped() {
+    	for(DragListener l : dragListeners) {
+    		l.draggingStopped();
+    	}
+    }
+    
+    /**
+     * Gathers and stores information about the graphics environment
+     * such as the combined screen area of a multiscreen environment
+     * and the shape its bounding polygon.
+     */
+    private void getEnvironmentInfo() {
+    	 GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
+         GraphicsDevice[] gs = ge.getScreenDevices();
+         virtualDeviceBounds = new ArrayList<Rectangle>();
+         virtualArea = new Area();
+         for (int j = 0; j < gs.length; j++) {
+             GraphicsDevice gd = gs[j];
+             GraphicsConfiguration[] gc = gd.getConfigurations();
+             for (int i=0; i < gc.length; i++) {
+            	 Rectangle r = gc[i].getBounds();
+            	 java.awt.Insets screenInsets = Toolkit.getDefaultToolkit().getScreenInsets(gc[i]);
+            	 r.x = r.x + screenInsets.left;
+            	 r.y = r.y + screenInsets.top;
+            	 r.setSize(r.width - (screenInsets.left + screenInsets.right),
+            		r.height - (screenInsets.top + screenInsets.bottom));
+            	 virtualDeviceBounds.add(r);
+            	 virtualArea.add(new Area(r));
+             }
+         } 
+    }
+    
+    /**
+     * Class which listens to mouse movements and alters the cursor to 
+     * the appropriate cursor for the given mouse location.
+     * 
+     * @author David Ray
+     */
+    class CursorManager extends MouseAdapter {
+        private boolean isPressed;
+        
+        @Override
+        public void mouseMoved(MouseEvent m) {
+	       Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+	       setCursorForSide(side);
+	    }
+        @Override
+        public void mouseExited(MouseEvent m) {
+            if(!isPressed) {
+            	setCursor(Cursor.getDefaultCursor());
+            }
+        }
+        @Override
+        public void mousePressed(MouseEvent m) {
+            isPressed = true;
+            Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+            setCursorForSide(side);
+        }
+        @Override
+        public void mouseReleased(MouseEvent m) {
+            isPressed = false;
+            setCursor(Cursor.getDefaultCursor());
+        }
+    }
+	
+	/**
+     * Handles the mouse events to control frame dragging
+     */
+    class MouseHandler extends MouseAdapter implements MouseMotionListener {
+    	private Rectangle frameRect;
+    	private Point startPoint;
+    	private Side startSide;
+    	
+    	public MouseHandler() {
+    		
+    	}
+    	
+    	@Override
+    	public void mousePressed(MouseEvent m) {
+    		frameRect = getBounds();
+    		startPoint = MouseInfo.getPointerInfo().getLocation();
+    		startSide = Side.sideFor(getBounds(), startPoint, resizeMargin);
+    		
+    		if(titleBar != null && titleBar.isControlHit(m)) {
+    			titleBar.mousePressed(m);
+    		}
+    	}
+    	
+    	public void mouseDragged(MouseEvent m) {
+    		Point p = MouseInfo.getPointerInfo().getLocation();
+    		
+    		int xAmount = (p.x - startPoint.x);
+    		int yAmount = (p.y - startPoint.y);
+    		DesktopFrame.this.isResizing = !isMoveOp(startSide);
+    		
+    		Rectangle prev = frameRect;
+    		frameRect = DesktopFrame.this.isResizing ? 
+    			resizeRectangle(frameRect, startSide, xAmount, yAmount) :
+    				moveRectangle(frameRect, xAmount, yAmount);
+    			
+    		setBounds(frameRect);
+    		fireWindowDragged(prev.getLocation(), frameRect.getLocation());
+    		startPoint = p;
+    		
+    		repaint();
+    	}
+    	
+    	public void mouseReleased(MouseEvent m) {
+    		if(titleBar != null && titleBar.isControlHit(m)) {
+    			titleBar.mouseReleased(m);
+    		}
+    		
+    		fireDraggingStopped();
+    	}
+    	
+    	public void mouseClicked(MouseEvent e) {
+    		if(e.getClickCount() > 1) {
+    			if((getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+    				setExtendedState(JFrame.NORMAL);
+    				setBorderSize(2);
+    			}else{
+    				setExtendedState(JFrame.MAXIMIZED_BOTH);
+    				setBorderSize(0);
+    			}
+    		}
+    	}
+    	
+    	private Rectangle moveRectangle(Rectangle r, int xAmount, int yAmount) {
+    		if((getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+    			return r;
+    		}
+    		Rectangle rect = new Rectangle(r);
+    		rect.setLocation(rect.x + xAmount, rect.y + yAmount);
+    	
+    		return rect;
+    	}
+    	
+    	private Rectangle resizeRectangle(Rectangle r, Side side, int deltaX, int deltaY) {
+    		Rectangle rect = new Rectangle(r);
+    		if(side.vertical() != 0 || side.horizontal() != 0) {
+    			if(side.vertical() == -1) {
+    				resizeTopTo(rect, r.y + deltaY);
+    			}else if(side.vertical() == 1) {
+    				resizeBottomTo(rect, (int)r.getMaxY() + deltaY);
+    			}
+    			
+    			if(side.horizontal() == -1) {
+    				resizeLeftTo(rect, r.x + deltaX);
+    			}else if(side.horizontal() == 1) {
+    				resizeRightTo(rect, (int)r.getMaxX() + deltaX);
+    			}
+    		}
+    		return rect;
+    	}
+    	
+    	private boolean isMoveOp(Side side) {
+    		return side == Side.NONE;
+    	}
+    	
+    	private void resizeLeftTo(Rectangle r, int x) {
+    		int sourceX = r.x;
+    		r.width -= (x - sourceX);
+    		r.x = x;
+    	}
+    	
+    	private void resizeRightTo(Rectangle r, int x) {
+    		int sourceX = (int)r.getMaxX();
+    		r.width += (x - sourceX);
+    	}
+    	
+    	private void resizeTopTo(Rectangle r, int y) {
+    		int sourceY = r.y;
+    		r.height -= (y - sourceY);
+    		r.y = y;
+    	}
+    	
+    	private void resizeBottomTo(Rectangle r, int y) {
+    		int sourceY = (int)r.getMaxY();
+    		r.height += (y - sourceY);
+    	}
+    }
+    
+    /**
+     * Class which represents the controls on a given title bar such as 
+     * minimize, maximize, and close.
+     * 
+     * @author David Ray
+     *@see TitleBarControl
+     */
+    class DefaultTitleBarControl extends TitleBarControl {
+    	private static final int SIDE_MARGIN = 10;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public DefaultTitleBarControl() {
+    		createControlShapes();
+    		
+    		addMouseListener(new MouseAdapter() {
+    			public void mousePressed(MouseEvent e) {
+    				if(minimizeRect.contains(e.getPoint())) {
+    					setExtendedState(ICONIFIED);
+    				}
+    				if(maximizeRect.contains(e.getPoint())) {
+    					if((getExtendedState() & MAXIMIZED_BOTH) == MAXIMIZED_BOTH) {
+    						setExtendedState(NORMAL);
+    					}else{
+    						setExtendedState(MAXIMIZED_BOTH);
+    					}
+    				}
+    				if(closeRect.contains(e.getPoint())) {
+    					System.exit(0);
+    				}
+    			}
+    		});
+    	}
+    	@Override
+    	public void paint(Graphics g) {
+    		if(!shapesInitialized) {
+    			createControlShapes();
+    			shapesInitialized = true;
+    		}
+    		
+    		Graphics2D g2 = (Graphics2D)g;
+    		g2.setColor(Color.BLACK);
+    		
+    		g2.setStroke(new BasicStroke(2));
+    		g2.drawLine((int)minimizeRect.getX(), (int)minimizeRect.getMaxY() - 3, 
+    			(int)minimizeRect.getMaxX() - 3, (int)minimizeRect.getMaxY() - 3);
+    		
+    		g2.draw(new Rectangle2D.Double(maximizeRect.getX() + 3, maximizeRect.getY() + 3, maximizeRect.getWidth() - 6, maximizeRect.getHeight() - 6));
+    		
+    		g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getY() + 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getMaxY() - 3);
+    		g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getMaxY() - 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getY() + 3);
+    	}
+    	@Override
+    	public void update(Graphics g) {
+    		paint(g);
+    	}
+    	
+    	private void createControlShapes() {
+    		int y = (getHeight() - 15) / 2;
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 15, 15);
+    		maximizeRect = new Rectangle2D.Double(SIDE_MARGIN + 16, y, 15, 15);
+    		closeRect = new Rectangle(SIDE_MARGIN + 32, y, 15, 15);
+    	}
+    }
+    
+    /**
+     * Creates a default {@link TitleBar}.
+     */
+    class DefaultTitleBar extends TitleBar {
+    	@Override
+		protected void paintTitle(Graphics2D g2) {
+			FontMetrics fm = g2.getFontMetrics();
+	        int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+	        g2.setColor(Color.BLACK);
+	        Rectangle r = g2.getClipBounds();
+	        int textX = (r.width - titleWidth) / 2;
+	        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+	        g2.drawString(title, textX, textY);
+		}
+
+		@Override
+		protected void fillTitleBar(Graphics2D g2) {
+			g2.setColor(Color.LIGHT_GRAY);
+			g2.fillRect(0, 0, getWidth(), getHeight());
+		}
+    }
+    
+    /**
+     * Defines methods which make available notifications regarding
+     * the stop and start of drag operations.
+     */
+    public static interface DragListener {
+    	public void windowDragged(Point oldLoc, Point newLoc);
+    	public void draggingStopped();
+    }
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java
new file mode 100644
index 0000000..4c4715f
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java
@@ -0,0 +1,397 @@
+package org.apache.pivot.wtk;
+
+import java.awt.AWTEvent;
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.LinearGradientPaint;
+import java.awt.Paint;
+import java.awt.RadialGradientPaint;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Stroke;
+import java.awt.Toolkit;
+import java.awt.event.AWTEventListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.WindowEvent;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+
+/**
+ * Used in conjunction with the {@link DesktopFrame} to provide an OSX-like 
+ * window title bar.
+ *  
+ * @author David Ray
+ *
+ */
+@SuppressWarnings("serial")
+public class OSXTitleBar extends TitleBar {
+	
+	
+	public OSXTitleBar() {
+		addTitleBarControl(createTitleBarControl());
+	}
+	
+	@Override
+	protected void paintTitle(Graphics2D g2) {
+		FontMetrics fm = g2.getFontMetrics();
+        int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+        g2.setColor(Color.WHITE);
+        Rectangle r = g2.getClipBounds();
+        int textX = (r.width - titleWidth) / 2;
+        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+        g2.drawString(title, textX + 1, textY + 1);
+        g2.setColor(Color.BLACK);
+        g2.drawString(title, textX, textY);
+	}
+	
+	@Override
+	protected void fillTitleBar(Graphics2D g2) {
+		Paint oldPaint = g2.getPaint();
+        Stroke oldStroke = g2.getStroke();
+        
+        g2.setColor(new Color(241,241,241));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(0, 0, getWidth(), 0);
+        
+        LinearGradientPaint p = new LinearGradientPaint(
+        	1f, 1f, 1f, getHeight() - 1,
+        		new float[] { 0.0f, 0.499f, 0.5f, 1.0f },
+        			new Color[] { new Color(230, 230, 230), new Color(202, 202, 202),
+        				new Color(202, 202, 202), new Color(178, 178, 178) });
+        g2.setPaint(p);
+        g2.fillRect(0, 0, getWidth(), this.getHeight() - 1);
+        
+        
+        g2.setPaint(oldPaint);
+        g2.setColor(new Color(104, 104, 104));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(getX(), getHeight() - 1, getWidth(), getHeight() - 1);
+        
+        g2.setStroke(oldStroke);
+	}
+	
+	private TitleBarControl createTitleBarControl() {
+		OSXTitleBarControl control = new OSXTitleBarControl();
+		control.setPreferredSize(new Dimension(60,20));
+		control.setControlLocation(TitleBar.Location.LEFT);
+		return control;
+	}
+	
+	class OSXTitleBarControl extends TitleBarControl {
+		private static final int SIDE_MARGIN = 8;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean mouseOverControl;
+    	private boolean maskMinimized;
+    	private boolean maskMaximized;
+    	private boolean maskClosed;
+    	
+    	private java.awt.Frame hostFrame;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public OSXTitleBarControl() {
+    		getParentFrame();
+    	}
+    	
+    	@Override
+    	public void paint(Graphics graphics) {
+    		Graphics2D g = (Graphics2D)graphics;
+    		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+    		
+    		if(!shapesInitialized) {
+    			createControlShapes();
+    			installListeners();
+    			shapesInitialized = true;
+    		}
+    		
+    		paintRedButton(g);
+    		paintYellowButton(g);
+    		paintGreenButton(g);
+    	}  
+    	
+    	private void paintRedButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)closeRect.getX(), (int)closeRect.getY() + 1, (int)closeRect.getWidth() - 1, (int)closeRect.getHeight());
+    		g2.setColor(new Color(134, 56, 51));
+    		g2.drawOval((int)closeRect.getX(), (int)closeRect.getY(), (int)closeRect.getWidth(), (int)closeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getCenterY()),
+    			(float)closeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(255,90,79), new Color(211,74,54) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getY() + (closeRect.getHeight() * 1.5) + 5),
+    			(float)closeRect.getWidth() - 2, new Point2D.Double(closeRect.getCenterX(), closeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 175), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getCenterY()), (float)closeRect.getWidth() * 1.5f,
+    			new Point2D.Double(closeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    		
+    		if(mouseOverControl) {
+    			g2.setColor(new Color(119,19,17));//90,11,10 -=-  119,19,17
+    			g2.setStroke(new BasicStroke(2));
+    			g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getY() + 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getMaxY() - 3);
+    			g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getMaxY() - 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getY() + 3);
+    			g2.setStroke(oldStroke);
+    		}
+    		
+    		if(maskClosed) {
+    			g2.setColor(new Color(0,0,0,75));
+    			g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		}
+    	}
+    	
+    	private void paintYellowButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)minimizeRect.getX(), (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth() - 1, (int)minimizeRect.getHeight());
+    		g2.setColor(new Color(115, 84, 47));
+    		g2.drawOval((int)minimizeRect.getX(), (int)minimizeRect.getY(), (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getCenterY()),
+    			(float)minimizeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(238,202,99), new Color(237,166,72) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getY() + (minimizeRect.getHeight() * 1.5) + 5),
+    			(float)minimizeRect.getWidth() - 2, new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 250), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getCenterY()), (float)minimizeRect.getWidth() * 1.5f,
+    			new Point2D.Double(minimizeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    		
+    		if(mouseOverControl) {
+    			g2.setColor(new Color(102,36,0));
+    			g2.drawLine((int)minimizeRect.getX() + 2, (int)minimizeRect.getCenterY(), (int)minimizeRect.getMaxX() - 2, (int)minimizeRect.getCenterY());
+    			g2.setColor(new Color(166,99,1));
+    			g2.drawLine((int)minimizeRect.getX() + 2, (int)minimizeRect.getCenterY() + 1, (int)minimizeRect.getMaxX() - 2, (int)minimizeRect.getCenterY() + 1);
+    		}
+    		
+    		if(maskMinimized) {
+    			g2.setColor(new Color(0,0,0,75));
+    			g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		}
+    	}
+    	
+    	private void paintGreenButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)maximizeRect.getX(), (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth() - 1, (int)maximizeRect.getHeight());
+    		g2.setColor(new Color(74, 96, 59));
+    		g2.drawOval((int)maximizeRect.getX(), (int)maximizeRect.getY(), (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getCenterY()),
+    			(float)maximizeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(194,242,147), new Color(116,174,86) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getY() + (maximizeRect.getHeight() * 1.5) + 5),
+    			(float)maximizeRect.getWidth() - 2, new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 250), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getCenterY()), (float)maximizeRect.getWidth() * 1.5f,
+    			new Point2D.Double(maximizeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    		
+    		if(mouseOverControl) {
+    			g2.setColor(new Color(0,53,-0));
+    			g2.setStroke(new BasicStroke(1));
+    			g2.drawLine((int)maximizeRect.getX() + 2, (int)maximizeRect.getCenterY(), (int)maximizeRect.getMaxX() - 2, (int)maximizeRect.getCenterY());
+    			g2.setColor(new Color(45,118,0));
+    			g2.drawLine((int)maximizeRect.getX() + 2, (int)maximizeRect.getCenterY() + 1, (int)maximizeRect.getMaxX() - 2, (int)maximizeRect.getCenterY() + 1);
+    			g2.setStroke(new BasicStroke(2));
+    			g2.setColor(new Color(0,53,-0));
+    			g2.drawLine((int)maximizeRect.getCenterX(), (int)maximizeRect.getY() + 2, (int)maximizeRect.getCenterX(), (int)maximizeRect.getY() + 3);
+    			g2.setColor(new Color(45,118,0));
+    			g2.drawLine((int)maximizeRect.getCenterX(), (int)maximizeRect.getY() + 3, (int)maximizeRect.getCenterX(), (int)maximizeRect.getMaxY() - 2);
+    		}
+    		
+    		if(maskMaximized) {
+    			g2.setColor(new Color(0,0,0,75));
+    			g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		}
+    	}
+    	
+    	private void createControlShapes() {
+    		int y = ((getHeight() - 10) / 2) - 1;
+    		closeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 10, 10);
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN + 20, y, 10, 10);
+    		maximizeRect = new Rectangle(SIDE_MARGIN + 40, y, 10, 10);
+    	}
+    	
+    	private void installListeners() {
+    		final Rectangle2D localCloseRect = new Rectangle2D.Double(
+				closeRect.getX() - 4, closeRect.getY() - 4, 
+					closeRect.getWidth() + 8, closeRect.getHeight() + 8);
+			final Rectangle2D localMinimizeRect = new Rectangle2D.Double(
+				minimizeRect.getX() - 4, minimizeRect.getY() - 4, 
+					minimizeRect.getWidth() + 8, minimizeRect.getHeight() + 8);
+			final Rectangle2D localMaximizeRect = new Rectangle2D.Double(
+				maximizeRect.getX() - 4, maximizeRect.getY() - 4, 
+					maximizeRect.getWidth() + 8, maximizeRect.getHeight() + 8);
+			
+			Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
+				 public void eventDispatched(AWTEvent e) {
+					 if(e.getID() == MouseEvent.MOUSE_RELEASED && mouseOverControl) {
+						 maskMinimized = maskMaximized = maskClosed = mouseOverControl = false;
+						 repaint();
+					 }
+				 }
+			}, AWTEvent.MOUSE_EVENT_MASK);
+    			
+    		addMouseListener(new MouseAdapter() {
+    			public void mouseReleased(MouseEvent e) {
+    				if(localMinimizeRect.contains(e.getPoint())) {
+    					fireFrameWillBecomeIconized();
+    					hostFrame.setExtendedState(JFrame.ICONIFIED);
+    				}else if(localMaximizeRect.contains(e.getPoint())) {
+    					if((hostFrame.getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+    						hostFrame.setExtendedState(JFrame.NORMAL);
+    					}else{
+    						hostFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
+    					}
+    				}else if(localCloseRect.contains(e.getPoint())) {
+    					WindowEvent wev = new WindowEvent(hostFrame, WindowEvent.WINDOW_CLOSING);
+    	                Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(wev);
+    				}
+    				maskMinimized = maskMaximized = maskClosed = false;
+    				repaint();
+    			}
+    			public void mousePressed(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p)) {
+						maskClosed = true;
+						maskMinimized = false;
+						maskMaximized = false;
+					}else if(localMinimizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = true;
+						maskMaximized = false;
+					}else if(localMaximizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = true;
+					}
+    				repaint();
+    			}
+    		});
+    		OSXTitleBarControl.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p) || localMinimizeRect.contains(p) || localMaximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					mouseOverControl = false;
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+    				}
+    				repaint();
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p) || localMinimizeRect.contains(p) || localMaximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						repaint();
+    				}
+    			}
+    		});
+    		OSXTitleBar.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				boolean prev = mouseOverControl;
+    				mouseOverControl = false;
+    				maskClosed = false;
+					maskMinimized = false;
+					maskMaximized = false;
+    				if(prev) {
+    					repaint();
+    				}
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p) || localMinimizeRect.contains(p) || localMaximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						repaint();
+    				}
+    			}
+    		});
+    	}
+    	
+    	private void getParentFrame() {
+    		(new Thread() {
+    			public void run() {
+    				while(hostFrame == null) {
+	    				try{ Thread.sleep(100); }catch(Exception e) { e.printStackTrace(); }
+	    				SwingUtilities.invokeLater(new Runnable() {
+	    					public void run() {
+	    						hostFrame = (java.awt.Frame)SwingUtilities.getAncestorOfClass(DesktopFrame.class, OSXTitleBarControl.this);
+	    					}
+	    				});
+    				}
+    			}
+    		}).start();
+    	}
+	}
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/ScrollBar.java b/pivot-wtk/src/org/apache/pivot/wtk/ScrollBar.java
index 4c211d2..ad550f4 100644
--- a/pivot-wtk/src/org/apache/pivot/wtk/ScrollBar.java
+++ b/pivot-wtk/src/org/apache/pivot/wtk/ScrollBar.java
@@ -305,8 +305,9 @@ public class ScrollBar extends Container {
             }
 
             if (value + extent > end) {
-                throw new IllegalArgumentException(String.format
-                    ("value (%d) + extent (%d) is greater than end (%d)", value, extent, end));
+            	return;
+//                throw new IllegalArgumentException(String.format
+//                    ("value (%d) + extent (%d) is greater than end (%d)", value, extent, end));
             }
 
             this.value = value;
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/SwingContainer.java b/pivot-wtk/src/org/apache/pivot/wtk/SwingContainer.java
new file mode 100644
index 0000000..f1a8ea4
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/SwingContainer.java
@@ -0,0 +1,837 @@
+package org.apache.pivot.wtk;
+
+import java.awt.AWTEvent;
+import java.awt.Color;
+import java.awt.EventQueue;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+import java.awt.event.AWTEventListener;
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowStateListener;
+import java.awt.image.BufferedImage;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.swing.JFrame;
+import javax.swing.JWindow;
+import javax.swing.SwingUtilities;
+
+import org.apache.pivot.wtk.DesktopFrame.DragListener;
+import org.apache.pivot.wtk.Window.WindowPopupListener;
+import org.apache.pivot.wtk.skin.PanelSkin;
+
+/**
+ * <pre>
+ * 
+ * 
+ *     -------------------------- o
+ *     |  o                      |  o  	   <---- Apache Pivot Component residing in the Pivot host component.
+ *     |       o                 |     o
+ *     |            o  -------------------
+ *     |               |                 | 
+ *     |               |                 |
+ *     |               |                 | <---- Awt Frame delegate which receives size information
+ *     |               |                 |		 and calculates location information translated to screen
+ *     |               |                 |		 coordinates from messages delegated from the Apache Pivot
+ *     |               |                 |       component.
+ *     |               |                 |
+ *     |               |                 |
+ *     |               |                 |         
+ *     ----------------|                 |
+ *       o             |                 |
+ *             o       |                 |
+ *                   o -------------------
+ * 
+ * 
+ * 
+ * Apache Pivot container which resides within the layout of the parent host.
+ * This container is never seen due to the delegate Swing JWindow which covers
+ * it, maintaining size and position information delegated to it from the 
+ * underlying Pivot container. 
+ * 
+ * Because the underlying ui upon receiving focus will come to the front
+ * of the delegate window, a low-level mouse listener is added so that the
+ * delegate window will always remain in front therefore making it appear
+ * as if the Swing component is actually inside the Apache container.
+ * 
+ * When the window containing the parent ui is moved, there will be a delay
+ * within which the delegate window will not move. Once the parent window has
+ * stopped moving briefly, the delegate window will update its position (or size
+ * in the case of resizing) to the "delegator's" position (or size).
+ * 
+ * One approach to dealing with this drawback is to fork the code providing
+ * an "undecorated frame" which subclasses {@link org.apache.pivot.wtk.DesktopApplicationContext.HostFrame}.
+ * The next step is to paint your own titlebar and add {@link MouseListener} to it 
+ * which can receive drag events and update the position of the frame (also causing
+ * the delegate window to update ongoingly and thus keeping the ui positioning 
+ * in sync). see {@link org.apache.pivot.wtk.DesktopFrame} for details
+ * 
+ * 
+ * @author David Ray
+ * @see org.apache.pivot.wtk.DesktopFrame
+ */
+public class SwingContainer extends Container implements WindowPopupListener {
+	private Skin skin;
+	private Delegate delegate;
+	Display display;
+	private java.awt.Window topLevelWindow;
+	private java.awt.Insets insets;
+	private javax.swing.Timer visibilityTimer;
+
+	private DragListener dragListener;
+	private WindowStateListener windowStateListener;
+	private TitleBar.IconizeListener iconizeListener;
+	private ComponentAdapter componentAdapter;
+	private AWTEventListener awtListener;
+
+	private java.awt.Component occupant;
+	
+	private BufferedImage background;
+	private boolean paintingBackground;
+	private boolean clientSetVisible;
+	private boolean isPopupTransition;
+	private boolean isDragging;
+	private boolean isDialogTransition;
+	
+	private int windowsOpened = 0;
+
+	private List<WindowDisposeListener> windowDisposeListeners;
+
+	/**
+	 * Creates a new {@code SwingContainer}
+	 * 
+	 * @param parent  the immediate parent container
+	 */
+	public SwingContainer() {
+		installSkin(ImageView.class);
+		
+		// Keeps the delegate window in front.
+		Toolkit.getDefaultToolkit().addAWTEventListener(awtListener = new AWTEventListener() {
+			@Override
+			public void eventDispatched(AWTEvent event) {
+				if (event.getID() == MouseEvent.MOUSE_PRESSED) {
+					if (delegate != null) {
+						delegate.toFront();
+					}
+				}else if(event.getID() == MouseEvent.MOUSE_MOVED) {
+					if(!isPopupTransition && !isDialogTransition && occupant != null && occupant.getBounds().width != 0) {
+						Point containerLoc = SwingContainer.this.getLocationOnScreen();
+						Point p = ((MouseEvent)event).getLocationOnScreen();
+						p.x -= (containerLoc.x + 5);
+						p.y -= (containerLoc.y + 5);
+						Rectangle r = occupant.getBounds();
+						if(paintingBackground && r.contains(p)) {
+							paintingBackground = false;
+							delegate.setVisible(true);
+						}
+					}
+				}else if(event.getID() == WindowEvent.WINDOW_CLOSING) {
+					if(((WindowEvent)event).getWindow() == topLevelWindow) {
+						isPopupTransition = true;
+						if(clientSetVisible) {
+							setContentAsBackground();
+						}
+					}
+				}
+			}
+		}, AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.WINDOW_EVENT_MASK);
+
+		// Delegate(java.awt.Window) must be instantiated with the top level window
+		// owner in order to receive focus. Therefore, we must wait until the top
+		// level window becomes available
+		(new Thread() {
+			public void run() {
+				while (getParent() == null
+						|| (display = getParent().getDisplay()) == null) {
+					try {
+						Thread.sleep(2000);
+					} catch (Exception e) {
+						e.printStackTrace();
+					}
+				}
+
+				topLevelWindow = display.getHostWindow();
+
+				// Delegate(java.awt.Window) must be instantiated with the top level window
+				// owner in order to receive focus. Therefore, we must wait until the top
+				// level window becomes available before instantiating the delegate(window).
+				// In addition all calls to mutate the delegate before it is instantiated -
+				// must also be delayed.
+				delegate = new Delegate(topLevelWindow);
+				
+				//Notification of tooltip/menu to dismiss SwingContainer so
+                //popup windows aren't covered by the SwingContainer Delegate
+				Window.getWindowPopupListeners().add(SwingContainer.this);
+				
+				if (occupant != null) {
+					processComponentAdd(occupant);
+				}
+
+				getParent().getContainerListeners().add(createContainerListener());
+
+				if (topLevelWindow instanceof DesktopFrame) {
+					((DesktopFrame) topLevelWindow).addDragListener(dragListener = new DragListener() {
+						public void windowDragged(Point oldLoc, Point newLoc) {
+							delegate.setVisible(false);
+							isDragging = true;
+						}
+
+						public void draggingStopped() {
+							isDragging = false;
+							Point p = getLocationOnScreen();
+							moveWindow(p.x, p.y);
+							if(clientSetVisible) {
+								delegate.setVisible(true);
+							}
+						}
+					});
+					//Sets the Delegate visibility for iconify/deiconify events.
+					((DesktopFrame) topLevelWindow).addWindowStateListener(windowStateListener = new WindowStateListener() {
+						@Override
+						public void windowStateChanged(WindowEvent e) {
+							if ((e.getNewState() & JFrame.ICONIFIED) == JFrame.ICONIFIED) {
+								delegate.setVisible(false);
+							} else {
+								delegate.setVisible(false);
+								(new Thread() {
+									public void run() {
+										try {
+											Thread.sleep(10);
+										} catch (Exception e) {
+											e.printStackTrace();
+										}
+										EventQueue.invokeLater(new Runnable() {
+											public void run() {
+												if(SwingContainer.this.getParent() != null) {
+													SwingContainer.this.getParent().invalidate();
+													SwingContainer.this.getParent().layout();
+													if(clientSetVisible) {
+														delegate.setVisible(true);
+														delegate.toFront();
+													}
+												}
+											}
+										});
+									}
+								}).start();
+							}
+						}
+					});
+					
+					TitleBar tb = ((DesktopFrame) topLevelWindow).getTitleBar();
+					if (tb != null) {
+						tb.addIconizeListener(iconizeListener = new TitleBar.IconizeListener() {
+							@Override
+							public void frameWillIconize() {
+								delegate.setVisible(false);
+							}
+						});
+					}
+				}
+				topLevelWindow.addComponentListener(componentAdapter = new ComponentAdapter() {
+					@Override
+					public void componentMoved(ComponentEvent e) {
+						Point p = getLocationOnScreen();
+						moveWindow(p.x, p.y);
+					}
+				});
+			}
+		}).start();
+
+		// Timer which is restarted to avoid setting the delegate visible until
+		// after any
+		// relocation or resizing is done.
+		visibilityTimer = new javax.swing.Timer(250,
+			new java.awt.event.ActionListener() {
+				public void actionPerformed(java.awt.event.ActionEvent e) {
+					delegate.setVisible(true);
+					delegate.requestFocus();
+				}
+			});
+
+		visibilityTimer.setRepeats(false);
+	}
+	
+	/**
+	 * Called from {@link Dummy} (in the case of Platform) /
+	 * Externally to resume state when application closing
+	 * is cancelled.
+	 */
+	public void applicationCloseCancelled() {
+		isPopupTransition = false;
+		isDialogTransition = false;
+		paintingBackground = false;
+		repaint();
+		if(clientSetVisible) {
+			delegate.setVisible(true);
+		}
+	}
+	
+	/** Implemetation of Window.WindowPopupListener */
+	@Override
+	public void popupOpened(Window popup) {
+		isPopupTransition = true;
+		if(clientSetVisible) {
+			setContentAsBackground();
+		}
+	}
+	
+	/** Implemetation of Window.WindowPopupListener */
+	@Override
+	public void popupClosed(Window popup) {}
+	
+	/** Implemetation of Window.WindowPopupListener */
+	@Override 
+	public void popupEnded(Window popup) {
+		isPopupTransition = false;
+	}
+	
+	public void dialogOpened() {
+		++windowsOpened;
+		
+		if(!isDialogTransition) {
+			if(clientSetVisible) {
+				setContentAsBackground();
+			}
+		}
+		isDialogTransition = true;
+	}
+	
+	public void dialogClosed() {
+		windowsOpened = Math.max(0, --windowsOpened);
+		if(windowsOpened == 0) {
+			isDialogTransition = false;
+			applicationCloseCancelled();
+		}
+	}
+	
+	public void onAddModeChanged(boolean isAddMode)  {
+		if(isAddMode) {
+			Toolkit.getDefaultToolkit().removeAWTEventListener(awtListener);
+			setContentAsBackground();
+		}else{
+			Toolkit.getDefaultToolkit().addAWTEventListener(awtListener,
+				AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.WINDOW_EVENT_MASK);
+			paintingBackground = false;
+			setVisible(true);
+		}
+	}
+	
+	/**
+	 * Sets this container visible and delegates to
+	 * the {@link Delegate} to set it visible as
+	 * well.
+	 */
+	@Override
+	public void setVisible(boolean b) {
+		if(delegate == null) {
+			queueSetVisible(b);
+		}else{
+			delegate.setVisible(b);
+		}
+	}
+	
+	/**
+	 * Returns a {@link BufferedImage} of the current
+	 * rendered contents.
+	 * 
+	 * @return	a {@link BufferedImage} of the current
+	 * rendered contents.
+	 */
+	public BufferedImage getSnapshot() {
+		if(delegate == null) return null;
+		return delegate.getSnapshot();
+	}
+	
+	/**x
+	 * Triggers the painting of the {@link Delegate}'s 
+	 * contents directly in this {@code SwingContainer} 
+	 * as an image. This is a workaround for allowing 
+	 * popups/menuss in the main window to appear to be
+	 * above the contents of the Delegate. 
+	 */
+	public void setContentAsBackground() {
+		if(!paintingBackground && getSize().width > 0 && getSize().height > 0) {
+			background = getSnapshot();
+			if(background == null) return; 
+			paintingBackground = true;
+			(new Thread() {
+				public void run() {
+					try{Thread.sleep(250);}catch(Exception e) {}
+					delegate.setVisible(false);
+				}
+			}).start();
+			repaint();
+		}
+	}
+	
+	/**
+	 * Only called by client code. Used to distinguish between
+	 * internal visibility requests and client visibility requests.
+	 * @param b
+	 */
+	public void clientSetVisible(boolean b) {
+		this.clientSetVisible = b;
+		this.setVisible(b);
+		if(b && delegate != null) {
+			delegate.toFront();
+		}
+	}
+	
+	/**
+	 * Called externally to retrieve the {@link #clientSetVisible}
+	 * flag indicating that the client is to remain visible/invisible
+	 * despite internal calls to {@link #setVisible(boolean)}
+	 * @return	true if so, false if not
+	 */
+	public boolean isClientSetVisible() {
+		return this.clientSetVisible;
+	}
+	
+	/**
+	 * Returns the overlying delegate window
+	 * @return	the overlying delegate window
+	 */
+	public java.awt.Window getHostWindow() {
+		return delegate;
+	}
+
+	/**
+	 * Must be called by users to get rid of {@link Window} resource.
+	 */
+	public void dispose() {
+		delegate.setVisible(false);
+		delegate.dispose();
+		removeListeners();
+		fireWindowDisposeEvent();
+	}
+
+	/**
+	 * Custom event to notify interested listeners of recent dispose call on
+	 * {@link SwingContainer}
+	 */
+	public class WindowDisposeEvent {
+		SwingContainer container;
+		int eventType;
+
+		public WindowDisposeEvent(SwingContainer c, int windowEventType) {
+			this.container = c;
+			this.eventType = windowEventType;
+		}
+
+		public SwingContainer getComponent() {
+			return container;
+		}
+
+		public int getEventType() {
+			return eventType;
+		}
+	}
+
+	/**
+	 * Listeners of this type receive notifications when this
+	 * {@link SwingContainer} has dispose called on it.
+	 */
+	public interface WindowDisposeListener {
+		public void windowDisposed(WindowDisposeEvent d);
+	}
+
+	/**
+	 * Adds the specified {@link WindowStateListener} to this
+	 * {@code SwingContainer}
+	 * 
+	 * @param wse
+	 */
+	public void addWindowDisposeListener(WindowDisposeListener wdl) {
+		if (windowDisposeListeners == null) {
+			windowDisposeListeners = new ArrayList<WindowDisposeListener>();
+		}
+		windowDisposeListeners.add(wdl);
+	}
+
+	/**
+	 * Removes the specified {@link WindowStateListener} from registration.
+	 * 
+	 * @param wse
+	 */
+	public void removeWindowStateListener(WindowStateListener wse) {
+		if (windowDisposeListeners == null)
+			return;
+		windowDisposeListeners.remove(wse);
+	}
+
+	/**
+	 * Notifies all registered {@link WindowStateEvent} listeners that this
+	 * container will dismiss it's delegate.
+	 */
+	private void fireWindowDisposeEvent() {
+		if (windowDisposeListeners != null) {
+			WindowDisposeEvent we = new WindowDisposeEvent(this, WindowEvent.WINDOW_CLOSING);
+			for (WindowDisposeListener wse : windowDisposeListeners) {
+				wse.windowDisposed(we);
+			}
+		}
+	}
+
+	/**
+	 * Removes all the listeners added to control and distribute behavioral
+	 * state.
+	 */
+	public void removeListeners() {
+		if (topLevelWindow != null) {
+			((DesktopFrame) topLevelWindow).removeDragListener(dragListener);
+			topLevelWindow.removeWindowStateListener(windowStateListener);
+			((DesktopFrame) topLevelWindow).getTitleBar().removeIconizeListener(iconizeListener);
+			topLevelWindow.removeComponentListener(componentAdapter);
+			Toolkit.getDefaultToolkit().removeAWTEventListener(awtListener);
+		}
+	}
+
+	/**
+	 * Listener which ensures that this "layered" container is visible.
+	 * 
+	 * @return ContainerListener
+	 */
+	private ContainerListener createContainerListener() {
+		return new ContainerListener.Adapter() {
+			@Override
+			public void componentInserted(Container container, int index) {
+				delegate.setVisible(true);
+			}
+		};
+	}
+
+	/**
+	 * Routes size information to the delegate
+	 * 
+	 * @param w
+	 *            width
+	 * @param h
+	 *            height
+	 */
+	public void setSize(int w, int h) {
+		if( w <= 1 || h <= 1) return;
+		
+		if (isDragging && delegate != null) {
+			if(clientSetVisible) {
+				visibilityTimer.restart();
+				delegate.setVisible(false);
+			}
+		}
+
+		super.setSize(w, h);
+		resizeWindow(w, h);
+		invalidate();
+		repaint();
+	}
+
+	/**
+	 * Routes location information to the delegate.
+	 * 
+	 * @param x
+	 *            coordinate
+	 * @param y
+	 *            coordinate
+	 */
+	public void setLocation(int x, int y) {
+		super.setLocation(x, y);
+		java.awt.Point convertedPoint = getLocationOnScreen();
+		moveWindow(convertedPoint.x, convertedPoint.y);
+	}
+
+	/**
+	 * Method used to add the Swing component to be hosted by this container.
+	 * 
+	 * @param c
+	 *            a java.awt.Component
+	 */
+	public void addSwingComponent(java.awt.Component c) {
+		if (c == null) {
+			throw new IllegalArgumentException("Component \"c\" cannot be null");
+		}
+
+		if (delegate == null) {
+			occupant = c;
+		} else {
+			processComponentAdd(c);
+		}
+
+	}
+
+	/**
+	 * Called directly if the "delegate" is instantiated, or by the delayed
+	 * initialization thread which waits for the top level window to be
+	 * available before instantiating the "delegate" so that the parent window
+	 * can be assigned at construction time.
+	 * 
+	 * @param c
+	 */
+	private void processComponentAdd(java.awt.Component c) {
+		java.awt.Component child = delegate.getChild();
+		if (child != null) {
+			delegate.remove(child);
+		}
+
+		delegate.add(c);
+		delegate.setVisible(true);
+		c.setFocusable(true);
+		occupant = c;
+	}
+
+	/**
+	 * Calculates the screen coordinates of this container which are used to
+	 * relocate the delegate window.
+	 * 
+	 * @return java.awt.Point the new screen coordinates of the delegate
+	 */
+	public java.awt.Point getLocationOnScreen() {
+		int xLocal = 0;
+		int yLocal = 0;
+
+		Component component = this;
+		while (component != null && component.isVisible()) {
+			if (component instanceof Display) {
+				java.awt.Window window = ((Display) component).getHostWindow();
+				xLocal += window.getX();
+				yLocal += window.getY();
+				if (window instanceof DesktopFrame) {
+					insets = ((DesktopFrame) window).getTitlebarInsets();
+				} else {
+					insets = window.getInsets();
+				}
+				xLocal += insets.left;
+				yLocal += insets.top;
+				break;
+			} else {
+				xLocal += component.getX();
+				yLocal += component.getY();
+			}
+			component = component.getParent();
+		}
+
+		return new java.awt.Point(xLocal, yLocal);
+	}
+
+	/**
+	 * Moves the delegate window to the specified coordinates.
+	 * 
+	 * @param x
+	 *            the horizontal coordinate
+	 * @param y
+	 *            the vertical coordinate
+	 */
+	boolean init = true;
+	public void moveWindow(int x, int y) {
+		if(init && (x <= 1 && y <= 1)) return;
+		init = false;
+		
+		if (delegate == null) {
+			queueMoveWindow(x, y);
+		} else {
+			delegate.setLocation(x, y);
+			delegate.toFront();
+		}
+	}
+
+	/**
+	 * Resizes the delegate window to the specified size.
+	 * 
+	 * @param w
+	 *            the new delegate width
+	 * @param h
+	 *            the new delegate height
+	 */
+	public void resizeWindow(int w, int h) {
+		if (delegate == null) {
+			queueResizeWindow(w, h);
+		} else {
+			delegate.setSize(w, h);
+			delegate.toFront();
+		}
+	}
+	
+	/**
+	 * 
+	 * @param x
+	 * @param y
+	 */
+	private void queueSetVisible(final boolean b) {
+		(new Thread() {
+			public void run() {
+				while (delegate == null) {
+					try {
+						Thread.sleep(100);
+					} catch (Exception e) {
+						e.printStackTrace();
+					}
+				}
+
+				EventQueue.invokeLater(new Runnable() {
+					public void run() {
+						SwingContainer.this.setVisible(b);
+					}
+				});
+			}
+		}).start();
+	}
+
+	/**
+	 * Waits until the delegate is available before issuing move calls.
+	 * 
+	 * @param x
+	 *            the new x location
+	 * @param y
+	 *            the new y location
+	 */
+	private void queueMoveWindow(final int x, final int y) {
+		(new Thread() {
+			public void run() {
+				while (delegate == null) {
+					try {
+						Thread.sleep(100);
+					} catch (Exception e) {
+						e.printStackTrace();
+					}
+				}
+
+				EventQueue.invokeLater(new Runnable() {
+					public void run() {
+						SwingContainer.this.moveWindow(x, y);
+						SwingContainer.this.invalidate();
+					}
+				});
+			}
+		}).start();
+	}
+
+	/**
+	 * Waits until delegate is available before issuing resize calls.
+	 * 
+	 * @param w
+	 *            the new width
+	 * @param h
+	 *            the new height
+	 */
+	private void queueResizeWindow(final int w, final int h) {
+		(new Thread() {
+			public void run() {
+				while (delegate == null) {
+					try {
+						Thread.sleep(100);
+					} catch (Exception e) {
+						e.printStackTrace();
+					}
+				}
+
+				EventQueue.invokeLater(new Runnable() {
+					public void run() {
+						SwingContainer.this.resizeWindow(w, h);
+					}
+				});
+			}
+		}).start();
+	}
+	
+	public void paint(Graphics2D g) {
+		if(paintingBackground) {
+			g.drawImage(background, 0, 0, null);
+		}else{
+			super.paint(g);
+			
+			g.setColor(Color.BLACK);
+			Rectangle r = g.getClipBounds();
+			g.fillRect(r.x, r.y, r.width, r.height);
+			g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+			g.setFont(g.getFont().deriveFont(30f).deriveFont(java.awt.Font.BOLD));
+			int x = SwingUtilities.computeStringWidth(g.getFontMetrics(), "Loading...");
+			int y = g.getFontMetrics().getMaxAscent();
+			
+			x = (r.width - x) / 2;
+			y = (r.height - y) / 2;
+			g.setColor(Color.WHITE);
+			g.drawString("Loading...", x, y);
+		}
+		
+	}
+
+	/**
+	 * Overridden to install a NOOP skin basically
+	 * 
+	 * @param componentClass
+	 *            ignored
+	 */
+	@Override
+	protected void installSkin(Class<? extends org.apache.pivot.wtk.Component> componentClass) {
+		skin = new PanelSkin();
+		setSkin(skin);
+	}
+
+	/**
+	 * Delegate {@link JWindow} which contains the Swing component which is kept
+	 * in sync with the Apache Pivot component {@link SwingContainer}
+	 * 
+	 * @author David Ray
+	 */
+	@SuppressWarnings("serial")
+	private class Delegate extends java.awt.Window {
+		private java.awt.Component child;
+
+		public Delegate(java.awt.Window parent) {
+			super(parent);
+		}
+
+		@Override
+		public void update(Graphics g) {
+			paint(g);
+		}
+
+		@Override
+		public java.awt.Component add(java.awt.Component c) {
+			this.child = c;
+			return super.add(c);
+		}
+
+		@Override
+		public void setSize(int w, int h) {
+			super.setSize(w, h);
+			if(child == null) return;
+			child.setSize(w, h);
+		}
+
+		private java.awt.Component getChild() {
+			return child;
+		}
+
+		@Override
+		public void remove(java.awt.Component c) {
+			super.remove(c);
+			if (c == child) {
+				child = null;
+			}
+		}
+		
+		public void setVisible(boolean b) {
+			super.setVisible(b);
+			if(b) {
+				setSize(SwingContainer.this.getSize().width, SwingContainer.this.getSize().height);
+				setLocation(SwingContainer.this.getLocationOnScreen());
+			}
+		}
+		
+		public BufferedImage getSnapshot() {
+			BufferedImage img = new BufferedImage(getSize().width, getSize().height, BufferedImage.TYPE_INT_ARGB);
+			Graphics g = img.getGraphics();
+			paint(g);
+			return img;
+		}
+	}
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
new file mode 100644
index 0000000..5d6a6af
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
@@ -0,0 +1,161 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BorderLayout;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.RenderingHints;
+import java.awt.event.MouseEvent;
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Titlebar to be used with the {@link DesktopFrame} class which provides
+ * template methods for styling the titlebar, inserting the control buttons
+ * (see {@link TitleBarControl}) and managing the frame's state.
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public abstract class TitleBar extends java.awt.Panel implements java.awt.event.MouseListener {
+	public enum Location { LEFT, CENTER, RIGHT };
+	
+	List<IconizeListener> iconizeListeners = new ArrayList<IconizeListener>();
+	
+	protected TitleBarControl control;
+	protected String title;
+	
+	public TitleBar() {
+		this("");
+	}
+	
+	public TitleBar(String title) {
+		this.title = title;
+		setLayout(new BorderLayout());
+	}
+	
+	public void addIconizeListener(IconizeListener l) {
+		if(l != null) {
+			iconizeListeners.add(l);
+		}
+	}
+	
+	public void removeIconizeListener(IconizeListener l) {
+		iconizeListeners.remove(l);
+	}
+	
+	public void fireFrameWillBecomeIconized() {
+		for(IconizeListener l : iconizeListeners) {
+			l.frameWillIconize();
+		}
+	}
+	
+	public boolean isControlHit(MouseEvent m) {
+		if(control != null) {
+			return control.isControlHit(m);
+		}
+		return false;
+	}
+	
+	public void setTitle(String title) {
+		this.title = title;
+	}
+	
+	@Override
+	public void mousePressed(MouseEvent m) {
+		if(control == null) return;
+		control.mousePressed(m);
+	}
+	
+	@Override
+	public void mouseReleased(MouseEvent m) {
+		if(control == null) return;
+		control.mouseReleased(m);
+	}
+	
+	//NO-OP
+	@Override public void mouseClicked(MouseEvent e) {}
+	@Override public void mouseEntered(MouseEvent e) {}
+	@Override public void mouseExited(MouseEvent e) {}
+	
+	/**
+	 * Adds the component housing the window controls (i.e. minimize/maximize buttons)
+	 * to this {@code TitleBar}
+	 * 
+	 * @param c		Subclass of {@link TitleBarControl}
+	 */
+	public void addTitleBarControl(TitleBarControl c) {
+		this.control = c;
+		if(this.control != null) {
+			remove(control);
+		}
+		
+		this.control = c;
+		switch(control.getControlLocation()) {
+			case LEFT: add(c, BorderLayout.WEST); break;
+			case CENTER: add(c, BorderLayout.CENTER); break;
+			case RIGHT : add(c, BorderLayout.EAST); break;
+		}
+	}
+	
+	/**
+	 * Adds a corner logo to the frame.
+	 * @param c	a java.awt.Component
+	 */
+	public void addSignature(java.awt.Component c) {
+			switch(control.getControlLocation()) {
+			//Opposite of the control
+			case LEFT: add(c, BorderLayout.EAST); break;
+			case RIGHT : add(c, BorderLayout.WEST); break;
+		}
+	}
+	
+	/**
+	 * Returns this {@code TitleBar}'s {@link TitleBarControl} if
+	 * any exists.
+	 * 
+	 * @return	the installed {@code TitleBarControl}
+	 */
+	public TitleBarControl getTitleBarControl() {
+		return control;
+	}
+	
+	@Override
+	public void paint(Graphics g) {
+        Graphics2D g2 = (Graphics2D)g;
+        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        
+        fillTitleBar(g2);
+        
+        //if clip is for child(i.e. TitleBarControl) don't paint it now.
+        //The clip indicates what's being painted. If the clip is the
+        //size of the titlebar then paint the title otherwise if the 
+        //clip is the clip representing the control, don't paint the 
+        //title into it, since we don't want them to overlap.
+        if(g2.getClipBounds().getSize().equals(getSize())) {
+        	paintTitle(g2);
+        }
+        //Paint the child component(TitleBarControl)
+        super.paint(g);
+    }
+	
+	@Override
+	public void update(Graphics g) {
+		paint(g);
+	}
+	
+	protected abstract void paintTitle(Graphics2D g2);
+	
+	protected abstract void fillTitleBar(Graphics2D g2);
+	
+	/**
+	 * Listened to by those classes wishing to be informed
+	 * when this {@link TitleBar}'s frame will be iconized.
+	 * 
+	 * @author David Ray
+	 */
+	public interface IconizeListener {
+		public void frameWillIconize();
+	}
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
new file mode 100644
index 0000000..a4b43db
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
@@ -0,0 +1,61 @@
+package org.apache.pivot.wtk;
+
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+
+
+/**
+ * Classes which are intended to provide titlebar control implementations 
+ * should be an extension of this class when used with the {@link TempFrame}
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public abstract class TitleBarControl extends java.awt.Component implements MouseListener, MouseMotionListener {
+	private TitleBar.Location titleBarLoc = TitleBar.Location.RIGHT;
+	
+	@Override
+	public void mouseDragged(MouseEvent e) {}
+
+	@Override
+	public void mouseMoved(MouseEvent e) {}
+
+	@Override
+	public void mouseClicked(MouseEvent e) {}
+
+	@Override
+	public void mousePressed(MouseEvent e) {}
+
+	@Override
+	public void mouseReleased(MouseEvent e) {}
+
+	@Override
+	public void mouseEntered(MouseEvent e) {}
+
+	@Override
+	public void mouseExited(MouseEvent e) {}
+	
+	/**
+	 * Sets the title bar location, see {@link TitleBar.Location}
+	 * 
+	 * @param loc
+	 */
+	public void setControlLocation(TitleBar.Location loc) {
+		if(loc == null) throw new NullPointerException("location can not be null");
+		this.titleBarLoc = loc;
+	}
+
+	/**
+	 * Returns the {@link TitleBar.Location}
+	 * @return	the {@link TitleBar.Location} of the control
+	 */
+	public TitleBar.Location getControlLocation() {
+		return this.titleBarLoc;
+	}
+	
+	public boolean isControlHit(MouseEvent e) {
+		return this.getBounds().contains(e.getPoint());
+	}
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/Window.java b/pivot-wtk/src/org/apache/pivot/wtk/Window.java
index 6fbdbfe..72bea59 100644
--- a/pivot-wtk/src/org/apache/pivot/wtk/Window.java
+++ b/pivot-wtk/src/org/apache/pivot/wtk/Window.java
@@ -435,6 +435,42 @@ public class Window extends Container {
             }
         }
     }
+    
+    /**
+     * Defines a listener interested in the opening/closing
+     * of "Popup" windows (i.e. menus, tooltips etc.)
+     * 
+     * The {@link Window} in question must have the String
+     * "ID:POPUP" in it's {@link UserDataDictionary} as 
+     * key/value.
+     * @author David Ray
+     */
+    public interface WindowPopupListener {
+    	public void popupOpened(Window popup);
+    	public void popupClosed(Window popup);
+    	public void popupEnded(Window popup);
+    }
+    
+    private static class WindowPopupListenerList extends WTKListenerList<WindowPopupListener> implements WindowPopupListener {
+    	@Override
+    	public void popupOpened(Window popup) {
+    		for(WindowPopupListener l : this) {
+    			l.popupOpened(popup);
+    		}
+    	}
+    	@Override
+    	public void popupClosed(Window popup) {
+    		for(WindowPopupListener l : this) {
+    			l.popupClosed(popup);
+    		}
+    	}
+    	@Override
+    	public void popupEnded(Window popup) {
+    		for(WindowPopupListener l : this) {
+    			l.popupEnded(popup);
+    		}
+    	}
+    }
 
     private Window owner = null;
     private ArrayList<Window> ownedWindows = new ArrayList<Window>();
@@ -460,6 +496,7 @@ public class Window extends Container {
     private WindowActionMappingListenerList windowActionMappingListeners = new WindowActionMappingListenerList();
 
     private static WindowClassListenerList windowClassListeners = new WindowClassListenerList();
+    private static WindowPopupListenerList popupListeners = new WindowPopupListenerList();
 
     private static Window activeWindow = null;
 
@@ -610,7 +647,6 @@ public class Window extends Container {
         if (ownerArgument == null) {
             throw new IllegalArgumentException();
         }
-
         open(ownerArgument.getDisplay(), ownerArgument);
     }
 
@@ -668,7 +704,11 @@ public class Window extends Container {
                 // Notify listeners
                 opening = false;
                 windowStateListeners.windowOpened(this);
-
+                
+                //Added by BarChart(David Ray): Notification of tooltip/menu to dismiss SwingContainer so
+                //popup windows aren't covered by the SwingContainer Delegate
+                popupListeners.popupOpened(this);
+                
                 moveToFront();
             } else {
                 if (vote == Vote.DENY) {
@@ -746,6 +786,15 @@ public class Window extends Container {
                     closing = false;
 
                     windowStateListeners.windowClosed(this, display, ownerLocal);
+                    
+ //                   if(getUserData().get("ID") != null && getUserData().get("ID").equals("POPUP")) {
+                    	popupListeners.popupClosed(this);
+                    	ApplicationContext.scheduleCallback(new Runnable() {
+                    		public void run() {
+                    			popupListeners.popupEnded(Window.this);
+                    		}
+                    	}, 250);
+//                    }
                 } else {
                     if (vote == Vote.DENY) {
                         closing = false;
@@ -1196,4 +1245,16 @@ public class Window extends Container {
     public static ListenerList<WindowClassListener> getWindowClassListeners() {
         return windowClassListeners;
     }
+    
+    /**
+     * Returns the list of {@link WindowPopupListener}s
+     * The list holds listeners registered to listen to open/close 
+     * events of those {@link Window} classes which have the key "ID",
+     * and the value "POPUP" registered in its {@link UserDataDictionary}
+     * 
+     * @return	the list of {@link WindowPopupListener}s
+     */
+    public static ListenerList<WindowPopupListener> getWindowPopupListeners() {
+    	return popupListeners;
+    }
 }
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/WindowsTitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/WindowsTitleBar.java
new file mode 100644
index 0000000..368a001
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/WindowsTitleBar.java
@@ -0,0 +1,431 @@
+package org.apache.pivot.wtk;
+
+import java.awt.AWTEvent;
+import java.awt.AlphaComposite;
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Composite;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.MultipleGradientPaint.CycleMethod;
+import java.awt.Polygon;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+import java.awt.event.AWTEventListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.WindowEvent;
+import java.awt.geom.Area;
+import java.awt.geom.GeneralPath;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.ConvolveOp;
+import java.awt.image.Kernel;
+
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+
+
+/**
+ * Mockup of a "Windows 7" titlebar, giving a "windowsy" look and
+ * feel when used in conjunction with a custom frame on a Windows 7
+ * os.
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public class WindowsTitleBar extends TitleBar {
+	
+	/**
+	 * Constructs a new {@code WindowsTitleBar}
+	 */
+	public WindowsTitleBar() {
+		addTitleBarControl(createTitleBarControl());
+	}
+	
+	@Override
+	protected void paintTitle(Graphics2D g2) {
+		// TODO Auto-generated method stub
+
+	}
+	
+	/**
+	 * Called by the {@link TitleBar} base class to paint 
+	 * the background of the titlebar.
+	 */
+	@Override
+	protected void fillTitleBar(Graphics2D g) {
+		Rectangle r = getBounds();
+		Color ltGray = Color.GRAY;
+		g.setColor(ltGray);
+		g.fillRoundRect(0,0,r.width, r.height + 15, 15, 15);
+		g.setColor(Color.BLACK);
+		g.drawRoundRect(0,0,r.width - 1, r.height + 15, 15, 15);
+		g.setColor(Color.WHITE);
+		g.drawRoundRect(1,1,r.width - 3, r.height + 15, 15, 15);
+	}
+	
+	/**
+	 * Creates the control containing the frame state
+	 * management buttons.
+	 * 
+	 * @return	{@link TitleBarControl}
+	 */
+	private TitleBarControl createTitleBarControl() {
+		WindowsTitleBarControl control = new WindowsTitleBarControl();
+		control.setPreferredSize(new Dimension(103,20));
+		control.setControlLocation(TitleBar.Location.RIGHT);
+		return control;
+	}
+	
+	class WindowsTitleBarControl extends TitleBarControl {
+		private static final int SIDE_MARGIN = 3;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean mouseOverControl;
+    	private boolean maskMinimized;
+    	private boolean maskMaximized;
+    	private boolean maskClosed;
+    	private boolean overMin;
+    	private boolean overMax;
+    	private boolean overClose;
+    	
+    	private java.awt.Frame hostFrame;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public WindowsTitleBarControl() {
+    		getParentFrame();
+    	}
+    	
+    	@Override
+    	public void paint(Graphics graphics) {
+    		super.paint(graphics);
+    		Graphics2D g = (Graphics2D)graphics;
+    		if(!shapesInitialized) {
+    			createTargetShapes();
+    			installListeners();
+    			shapesInitialized = true;
+    		}
+    		
+    		paintControl(g);
+    	}
+    	
+    	@Override
+    	public void update(Graphics g) {
+    		paint(g);
+    	}
+    	
+    	protected void paintControl(Graphics2D g) {
+    		Rectangle r = g.getClipBounds();
+    		Graphics2D g2 = (Graphics2D)g;
+    		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
+    		
+    		//The control box
+    		g2.setColor(Color.BLACK);
+    		g2.drawRoundRect(r.width - 99, -10, 90, 29, 10, 10);
+    		g2.setColor(Color.WHITE);
+    		g2.drawRoundRect(r.width - 100, -9, 92, 29, 10, 10);
+    		
+    		//The controls
+    		int x = r.width - 98;
+    		GeneralPath path = new GeneralPath();
+    		
+    		//Button 1
+    		path.moveTo(x, 2);
+    		path.lineTo(x, 14);
+    		path.curveTo(x, 14, x, 16, x + 4, 18);
+    		path.lineTo(x + 23, 18);
+    		path.lineTo(x + 23, 2);
+    		g2.draw(path);
+    		
+    		//Button 2
+    		g2.setColor(Color.BLACK);
+    		g2.drawLine(x + 24, 0, x + 24, 18);
+    		g2.setColor(Color.WHITE);
+    		g2.drawLine(x + 25, 2, x + 25, 18);
+    		g2.drawLine(x + 25, 18, x + 47, 18);
+    		g2.drawLine(x + 47, 18, x + 47, 2);
+    		
+    		//Button 3
+    		g2.setColor(Color.BLACK);
+    		g2.drawLine(x + 48, 18, x + 48, 0);
+    		g2.setColor(Color.WHITE);
+    		path.moveTo(x + 49, 2);
+    		path.lineTo(x + 49, 18);
+    		path.lineTo(x + 85, 18);
+    		path.curveTo(x + 85, 18, x + 85, 16, x + 88, 14);
+    		path.lineTo(x + 88, 2);
+    		g2.draw(path);
+    		g2.setColor(new Color(186,56,33));
+    		g2.fillRect(x + 49, 1, 38, 18);
+    		g2.fillRect(x + 49, 1, 40, 15);
+    		g2.drawLine(x + 49, 16, x + 88, 16);
+    		g2.drawLine(x + 49, 17, x + 87, 17);
+    		
+//    		image = getGaussianBlurFilter(5, true).filter(image, null);
+//    		image = getGaussianBlurFilter(5, false).filter(image, null);
+//    		
+//    		g.drawImage(image, 0, 0, null);
+//    		
+//    		g2.dispose();
+    		
+    		//Reflection on upper half of all 3 buttons
+    		Composite oldComp = g2.getComposite();
+    		g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    		
+    		Point2D start = new Point2D.Double(x, 2);
+    		Point2D end = new Point2D.Double(x, 9);
+    		float[] fractions = new float[] { 0.0f, 1.0f };
+    		Color[] colors = new Color[] { Color.WHITE, Color.GRAY };
+    		java.awt.LinearGradientPaint lgp = new java.awt.LinearGradientPaint(start, end, fractions, colors, CycleMethod.NO_CYCLE);
+    		
+    		g2.setPaint(lgp);//Color.WHITE);
+    		g2.fillRect(x, 2, 23, 9); //Button 1
+    		g2.fillRect(x + 25, 2, 23, 9); //Button 2
+    		g2.fillRect(x + 48, 1, 41, 9); //Button 3
+    		
+    		g2.setComposite(AlphaComposite.SrcOver.derive(0.5f));
+    		start = new Point2D.Double(x, 9);
+    		end = new Point2D.Double(x, 18);
+    		fractions = new float[] { 0.0f, 1.0f };
+    		colors = new Color[] { Color.DARK_GRAY, Color.LIGHT_GRAY };
+    		lgp = new java.awt.LinearGradientPaint(start, end, fractions, colors, CycleMethod.NO_CYCLE);
+    		
+//    		g2.setPaint(lgp);
+//    		g2.fillRect(x, 10, 23, 16); //Button 1
+//    		g2.fillRect(x + 25, 10, 23, 16); //Button 2
+//    		g2.fillRect(x + 48, 10, 41, 17); //Button 3
+    		
+    		g2.setComposite(oldComp); //Reverse alpha composite
+    		
+    		//Button symbols
+    		g2.setColor(Color.WHITE);
+    		g2.fillRect(x + 7, 11, 10, 3);
+    		g2.setColor(Color.BLACK);
+    		g2.drawRect(x + 7, 10, 10, 4);
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.setStroke(new BasicStroke(2));
+    		g2.drawRect(x + 31, 6, 10, 7);
+    		g2.setColor(Color.BLACK);
+    		g2.setStroke(new BasicStroke(1));
+    		g2.drawRect(x + 30, 5, 12, 9);
+    		g2.drawRect(x + 33, 8, 6, 3);
+    		
+    		Area xfig = new Area(new Rectangle(x + 62, 5, 14, 8));
+    		int[] xpoints = new int[]{ x + 62, x + 66, x + 62 };
+    		int[] ypoints = new int[] { 5, 9, 13 };
+    		Polygon p = new Polygon(xpoints, ypoints, 3);
+    		Area leftTri = new Area(p);
+    		xfig.subtract(leftTri);
+    		xpoints = new int[]{ x + 66, x + 69, x + 72 };
+    		ypoints = new int[] { 5, 8, 5 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area topTri = new Area(p);
+    		xfig.subtract(topTri);
+    		xpoints = new int[]{ x + 76, x + 72, x + 76 };
+    		ypoints = new int[] { 5, 9, 13 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area rightTri = new Area(p);
+    		xfig.subtract(rightTri);
+    		xpoints = new int[]{ x + 66, x + 69, x + 72 };
+    		ypoints = new int[] { 13, 10, 13 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area bottomTri = new Area(p);
+    		xfig.subtract(bottomTri);
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.fill(xfig);
+    		g2.setColor(Color.BLACK);
+    		g2.draw(xfig);
+    		
+    		if(mouseOverControl) {
+    			if(maskMinimized) {
+    				g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    				g2.setColor(Color.DARK_GRAY);
+    				g2.fill(minimizeRect);
+    			}else if(maskMaximized) {
+    				g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    				g2.setColor(Color.DARK_GRAY);
+    				g2.fill(maximizeRect);
+    			}else if(maskClosed) {
+    				g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    				g2.setColor(Color.DARK_GRAY);
+    				g2.fill(closeRect);
+    			}
+    			
+    			g2.setComposite(oldComp);
+    		}
+    	}
+    	
+    	private void createTargetShapes() {
+    		int y =  1;
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 25, 20);
+    		maximizeRect  = new Rectangle2D.Double(SIDE_MARGIN + 25, y, 25, 20);
+    		closeRect = new Rectangle(SIDE_MARGIN + 50, y, 40, 20);
+    	}
+    	
+    	private void installListeners() {
+    		Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
+				 public void eventDispatched(AWTEvent e) {
+					 if(e.getID() == MouseEvent.MOUSE_RELEASED && mouseOverControl) {
+						 maskMinimized = maskMaximized = maskClosed = mouseOverControl = false;
+						 repaint();
+					 }
+				 }
+			}, AWTEvent.MOUSE_EVENT_MASK);
+    			
+    		addMouseListener(new MouseAdapter() {
+    			public void mouseReleased(MouseEvent e) {
+    				if(minimizeRect.contains(e.getPoint())) {
+    					fireFrameWillBecomeIconized();
+    					hostFrame.setExtendedState(JFrame.ICONIFIED);
+    				}else if(maximizeRect.contains(e.getPoint())) {
+    					if((hostFrame.getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+    						hostFrame.setExtendedState(JFrame.NORMAL);
+    					}else{
+    						hostFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
+    					}
+    				}else if(closeRect.contains(e.getPoint())) {
+    					WindowEvent wev = new WindowEvent(hostFrame, WindowEvent.WINDOW_CLOSING);
+    	                Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(wev);
+    				}
+    				maskMinimized = maskMaximized = maskClosed = false;
+    				repaint();
+    			}
+    			public void mousePressed(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(closeRect.contains(p)) {
+						maskClosed = true;
+						maskMinimized = false;
+						maskMaximized = false;
+					}else if(minimizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = true;
+						maskMaximized = false;
+					}else if(maximizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = true;
+					}
+    				repaint();
+    			}
+    		});
+    		WindowsTitleBarControl.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if((overClose = closeRect.contains(p)) || (overMin = minimizeRect.contains(p)) || (overMax = maximizeRect.contains(p))) {
+    					mouseOverControl = true;
+    					overClose = !overMin && !overMax;
+    					overMin = !overClose && !overMax;
+    					overMax = !overMin && !overClose;
+    				}else{
+    					mouseOverControl = false;
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						overMin = false;
+						overClose = false;
+						overMax = false;
+    				}
+    				
+    				repaint();
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(closeRect.contains(p) || minimizeRect.contains(p) || maximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						
+						repaint();
+    				}
+    			}
+    		});
+    		WindowsTitleBar.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				boolean prev = mouseOverControl;
+    				mouseOverControl = false;
+    				maskClosed = false;
+					maskMinimized = false;
+					maskMaximized = false;
+    				if(prev) {
+    					repaint();
+    				}
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(closeRect.contains(p) || minimizeRect.contains(p) || maximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						repaint();
+    				}
+    			}
+    		});
+    	}
+    	
+    	private void getParentFrame() {
+    		(new Thread() {
+    			public void run() {
+    				while(hostFrame == null) {
+	    				try{ Thread.sleep(100); }catch(Exception e) { e.printStackTrace(); }
+	    				SwingUtilities.invokeLater(new Runnable() {
+	    					public void run() {
+	    						hostFrame = (java.awt.Frame)SwingUtilities.getAncestorOfClass(DesktopFrame.class, WindowsTitleBarControl.this);
+	    						WindowsTitleBar.this.invalidate();
+	    						WindowsTitleBar.this.validate();
+	    						WindowsTitleBar.this.repaint();
+	    					}
+	    				});
+    				}
+    			}
+    		}).start();
+    	}
+	}
+
+	
+	
+	public ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal) {
+	     if (radius < 1) {
+	    	 throw new IllegalArgumentException(
+	             "Radius must be >= 1");
+	     }
+
+	     int size = radius * 2 + 1;
+	     float[] data = new float[size];
+	     float sigma = radius / 3.0f;
+	     float twoSigmaSquare = 2.0f * sigma * sigma;
+	     float sigmaRoot = (float)
+	         Math.sqrt(twoSigmaSquare * Math.PI);
+	     float total = 0.0f;
+	     for (int i = -radius; i <= radius; i++) {
+	    	 float distance = i * i;
+	       	int index = i + radius;
+	       	data[index] = (float) Math.exp(-distance / twoSigmaSquare) / sigmaRoot;
+	       	total += data[index];
+	     }
+
+	     for (int i = 0; i < data.length; i++) {
+	    	 data[i] /= total;
+	     }
+
+	     Kernel kernel = null;
+	     if(horizontal) {
+	    	 kernel = new Kernel(size, 1, data);
+	     }else{
+	    	 kernel = new Kernel(1, size, data);
+	     }
+	     return new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);
+	 }
+
+}
