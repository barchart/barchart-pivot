diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
index eb23b16..c85a306 100644
--- a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
@@ -192,6 +192,22 @@ public final class DesktopApplicationContext extends ApplicationContext {
             }
         }
     }
+    
+    /**
+     * Returns an {@link EventEnabledFrame} if the java version is greater
+     * than or equal to 7. The returned frame is capable of painting its own
+     * title bar so that move events on the frame (normally not able to
+     * be received), can be dispatched.
+     * 
+     * @return	an instance of EventEnabledFrame
+     */
+    protected static HostFrame getHostFrame() {
+    	if(isRunningVersion7OrGreater()) {
+    		System.out.println("Running extended capability pivot fork.");
+    		return new DesktopFrame();
+    	}
+    	return new HostFrame();
+    }
 
     // The AWT Window class does not define a title property; this interface allows
     // the HostFrame and HostDialog titles to be handled polymorphically
@@ -201,11 +217,13 @@ public final class DesktopApplicationContext extends ApplicationContext {
     }
 
     // Native host frame
-    private static class HostFrame extends java.awt.Frame implements TitledWindow {
+    // David Ray : Forked change of access level (from private to protected) to this class and its extention
+    //			  to javax.swing.JFrame from java.awt.Frame
+    protected static class HostFrame extends javax.swing.JFrame implements TitledWindow {
         private static final long serialVersionUID = 5340356674429280196L;
 
         public HostFrame() {
-            enableEvents(AWTEvent.WINDOW_EVENT_MASK
+        	enableEvents(AWTEvent.WINDOW_EVENT_MASK
                 | AWTEvent.WINDOW_STATE_EVENT_MASK);
 
             // Disable focus traversal keys
@@ -479,7 +497,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         boolean center = false;
         boolean resizable = true;
         boolean maximized = false;
-        boolean undecorated = false;
+        boolean undecorated = isRunningVersion7OrGreater();
         boolean fullScreen = false;
         boolean preserveSplashScreen = false;
 
@@ -564,7 +582,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         displays.add(primaryDisplayHost.getDisplay());
 
         // Create the windowed host frame
-        windowedHostFrame = new HostFrame();
+        windowedHostFrame = getHostFrame();
         windowedHostFrame.add(primaryDisplayHost);
         windowedHostFrame.setUndecorated(undecorated);
 
@@ -647,6 +665,18 @@ public final class DesktopApplicationContext extends ApplicationContext {
             });
         }
     }
+    
+    /**
+     * Called from the declaration of "undecorated" which calls
+     * {@link #isRunningVersion7OrGreater()} to determine if it is
+     * safe to create a custom barchart frame.
+     * 
+     * @return	flag indicating whether the java version is >= 1.7
+     */
+    private static boolean isRunningVersion7OrGreater() {
+    	String version = System.getProperty("java.version");
+    	return Integer.parseInt(version.split("\\.")[1]) >= 7;
+    }
 
     private static void initializeOSExtensions() {
         String osName = System.getProperty("os.name");
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
new file mode 100644
index 0000000..01d3006
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
@@ -0,0 +1,1011 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BasicStroke;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Cursor;
+import java.awt.Dimension;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.MouseInfo;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Toolkit;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.geom.Area;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.BufferedImage;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.swing.JComponent;
+import javax.swing.JFrame;
+import javax.swing.JMenuBar;
+import javax.swing.JPanel;
+import javax.swing.JRootPane;
+import javax.swing.SwingUtilities;
+import javax.swing.event.MouseInputAdapter;
+
+
+/**
+ * Sub-class of {@link JFrame} which supports custom frame movement
+ * functionality
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public class DesktopFrame extends DesktopApplicationContext.HostFrame {
+    /** The JComponent shown as the title bar decoration */
+    private TitleBar titleBar;
+    /** The default height of the title bar */
+    private int titleBarHeight = 22;
+    /** The main content panel housing the user content */
+    private JComponent mainContentPanel;
+    /** The left border component which detects mouse events for cursor manipulation and resizing */
+    private JComponent leftBorderComponent;
+    /** The right border component which detects mouse events for cursor manipulation and resizing */
+    private JComponent rightBorderComponent;
+    /** The bottom border component which detects mouse events for cursor manipulation and resizing */
+    private JComponent bottomBorderComponent;
+    
+    private Component userPanel; 
+    
+    private CursorManager cursorManager;
+    
+    private boolean isBorderDecorated;
+    /** Container of both the title bar and optional JMenuBar */
+    private JPanel titlebarContainer;
+    /** The optional JMenuBar */
+    private JMenuBar menuBar;
+    
+    private int borderSize = 1;
+    private int resizeMargin = borderSize;
+    
+    private Color borderColor = new Color(120, 120, 120);
+    
+    private List<Rectangle> virtualDeviceBounds;
+    private Area virtualArea;
+    
+    private BufferedImage storedImage;
+    private boolean isDragging;
+    private boolean isResizing;
+    
+    private List<DragListener> dragListeners = new ArrayList<DragListener>();
+    
+    
+    
+    
+    /**
+     * Constructs a new {@code DesktopFrame}
+     * 
+     * @param title     the String to be used as the title.
+     * @param gc        the GraphicsConfiguration to be used.
+     */
+    public DesktopFrame() {
+        setUndecorated(true);
+        super.setLayout(new BorderLayout());
+        setTitleBar(createTitleBar());
+        
+        getRootPane().putClientProperty("Window.alpha", new Float(1));
+        
+        //The following 3 lines are temporary as location/size info for development.
+        JPanel p = createMainContentPanel();
+        addMainContentPanel(p);
+        setBorderDecorated(true, true);
+        reshapeBorders();
+        getEnvironmentInfo();   
+    }
+    
+    /**
+     * Adds the specified {@link DragListener} to this {@code DesktopFrame}
+     * @param d		the {@code DragListener} to add.
+     */
+    public void addDragListener(DragListener d) {
+    	if(d != null) {
+    		dragListeners.add(d);
+    	}
+    }
+    
+    /**
+     * Fires a window dragged event to registered listeners.
+     * 
+     * @param oldLoc
+     * @param newLoc
+     */
+    public void fireWindowDragged(Point oldLoc, Point newLoc) {
+    	for(DragListener l : dragListeners) {
+    		l.windowDragged(oldLoc, newLoc);
+    	}
+    }
+    
+    /**
+     * Fires an event notifiying {@link DragListener}s that
+     * dragging has stopped.
+     */
+    public void fireDraggingStopped() {
+    	for(DragListener l : dragListeners) {
+    		l.draggingStopped();
+    	}
+    }
+    
+    /**
+     * Gathers and stores information about the graphics environment
+     * such as the combined screen area of a multiscreen environment
+     * and the shape its bounding polygon.
+     */
+    private void getEnvironmentInfo() {
+    	 GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
+         GraphicsDevice[] gs = ge.getScreenDevices();
+         virtualDeviceBounds = new ArrayList<Rectangle>();
+         virtualArea = new Area();
+         for (int j = 0; j < gs.length; j++) {
+             GraphicsDevice gd = gs[j];
+             GraphicsConfiguration[] gc = gd.getConfigurations();
+             for (int i=0; i < gc.length; i++) {
+            	 Rectangle r = gc[i].getBounds();
+            	 java.awt.Insets screenInsets = Toolkit.getDefaultToolkit().getScreenInsets(gc[i]);
+            	 r.x = r.x + screenInsets.left;
+            	 r.y = r.y + screenInsets.top;
+            	 r.setSize(r.width - (screenInsets.left + screenInsets.right),
+            		r.height - (screenInsets.top + screenInsets.bottom));
+            	 virtualDeviceBounds.add(r);
+            	 virtualArea.add(new Area(r));
+             }
+         } 
+    }
+    
+    /**
+     * Protects against a frame location being out of aggregate
+     * device bounds by repositioning the upper left corner of a
+     * frame that is out of virtual device bounds to be within
+     * the bounds of the closest screen.
+     * 
+     * @param p		the location in question
+     * @return		the most ideal location, or the same point if
+     * 				that point is location within virtual device
+     * 				bounds.
+     */
+    private Point getValidLocationFor(Point p) {
+    	if(virtualDeviceBounds == null) {
+    		return p;
+    	}
+    	
+    	if(!virtualArea.contains(p)) {
+    		Rectangle r = getClosestDevice(p);
+    		p.x = Math.max(r.x, p.x);
+			p.x = Math.min((int)r.getMaxX(), p.x);
+			p.y = Math.max(r.y, p.y);
+			p.y = Math.min((int)r.getMaxY(), p.y);
+    	}
+    	return p;
+    }
+    
+    /**
+     * Called when the suggested location passed in by 
+     * the windowing environment (read Pivot) is outside
+     * the device bounds described by the combined graphics
+     * devices. This happens for sure with Mac OSX due to 
+     * the existence of the MenuBar on top.
+     * 
+     * @param p
+     * @return		the bounds of the closest screen relative 
+     * 				to the {@link Point} passed in.
+     */
+    private Rectangle getClosestDevice(Point p) {
+    	double distance = Integer.MAX_VALUE;
+    	Rectangle closest = null;
+    	for(Rectangle r : virtualDeviceBounds) {
+    		if(p.distance(r.getLocation()) < distance) {
+    			closest = r;
+    			distance = p.distance(r.getLocation());
+    		}
+    	}
+    	return closest;
+    }
+    
+    @Override
+    public void setLocation(int x, int y) {
+    	Point p = getValidLocationFor(new Point(x, y));
+    	super.setLocation(p.x, p.y);
+    }
+    
+    @Override
+    public void setLocation(Point p) {
+    	super.setLocation(getValidLocationFor(p));
+    }
+    
+    /**
+     * Sets the {@link TitleBar} component.
+     * @param c		the TitleBar component.
+     */
+    public void setTitleBar(TitleBar c) {
+        if(titlebarContainer == null) {
+            titlebarContainer = new JPanel(new BorderLayout());
+            super.add(titlebarContainer, BorderLayout.NORTH);
+        }
+        removeTitleBar();
+        this.titleBar = c;
+        titleBarHeight = c.getHeight();
+        titlebarContainer.add(c, BorderLayout.NORTH);
+        addCursorHandler();
+        installMouseHandler(new MouseHandler());
+        invalidate();
+        validate();
+        repaint();
+    }
+    
+    /**
+     * Removes the {@link TitleBar} component
+     * @return	the removed TitleBar component.
+     */
+    public JComponent removeTitleBar() {
+        if(titlebarContainer == null) {
+            titlebarContainer = new JPanel(new BorderLayout());
+        }
+        if(titleBar != null) {
+            titlebarContainer.remove(titleBar);
+        }
+        JComponent c = titleBar;
+        this.titleBar = null;
+        setTitleBarHeight(0);
+        return c;
+    }
+    
+    /**
+     * Called by the SwingContainer class to determine the location
+     * to set on the delegate Window.
+     * @return
+     */
+    public java.awt.Insets getTitlebarInsets() {
+    	java.awt.Insets superInsets = super.getInsets();
+    	return new java.awt.Insets(
+    		titleBar.getPreferredSize().height, superInsets.left, 
+    			superInsets.bottom, superInsets.right);
+    }
+    
+    @Override
+    public void setJMenuBar(JMenuBar menuBar) {
+        this.menuBar = menuBar;
+        if(menuBar != null) {
+            titlebarContainer.add(menuBar, BorderLayout.SOUTH);
+        }
+    }
+    
+    @Override
+    public JMenuBar getJMenuBar() {
+        return menuBar;
+    }
+    
+    /**
+     * Sets the color that will be used to paint the border.
+     * @param c		the border color
+     */
+    public void setBorderColor(Color c) {
+        this.borderColor = c;
+    }
+    
+    /**
+     * Returns the color that is used to paint the border
+     * @return	the current border color
+     */
+    public Color getBorderColor() {
+        return borderColor;
+    }
+    
+    /**
+     * Sets the size in pixels of the frame border
+     * 
+     * @param size	the frame border size.
+     */
+    public void setBorderSize(int size) {
+        borderSize = size;
+        if(isDisplayable()) {
+            reshapeBorders();
+        }
+    }
+    
+    /**
+     * Returns the border size.
+     * @return	the border size.
+     */
+    public int getBorderSize() {
+        return borderSize;
+    }
+    
+    /**
+     * Sets the height in pixels of the title bar.
+     * 
+     * @param height	the height of the title bar
+     */
+    public void setTitleBarHeight(int height) {
+        titleBarHeight = height;
+    }
+    
+    /**
+     * Returns the title bar height
+     * 
+     * @return	the current title bar height
+     */
+    public int getTitleBarHeight() {
+        return titleBarHeight;
+    }
+    
+    /**
+     * Returns the {@link Container} the user added to this
+     * frame.
+     */
+    @Override
+    public Container getContentPane() {
+        if(userPanel == null) {
+            return super.getContentPane();
+        }
+        return (Container)userPanel;
+    }
+    
+    /**
+     * Adds the component which is the parent of all other components
+     * residing within this frame of the user's ui. This frame has only one layout 
+     * manager ({@link BorderLayout}) which host's the component argument in its 
+     * {@link BorderLayout.CENTER} position. This is necessary in order to
+     * paint the frame's attributes such as left, right and bottom borders (optional), 
+     * and the title bar, which are usually handled by the windowing framework itself.
+     * 
+     * Only one component may be added to this frame, and any attempts to add subsequent
+     * components will trigger the removal of any previously added component, following
+     * this, the component added is automatically added to the center 
+     * of this frame's {@code BorderLayout}, thereby ignoring all other parameters of any
+     * other add(x, y, z) methods which delegate to this method.
+     * 
+     * @param comp	the component to add to the {@link BorderLayout.CENTER} of this frame.
+     */
+    @Override
+    public Component add(Component comp) {
+        if(userPanel != null) {
+            mainContentPanel.remove(userPanel);
+        }
+        if(userPanel != null) {
+        	mainContentPanel.remove(userPanel);
+        }
+        this.userPanel = comp;
+        mainContentPanel.add(userPanel, BorderLayout.CENTER);
+        return comp;
+    }
+    
+    /**
+     * Delegates to {@link #add(Component)}.
+     * @see DesktopFrame#add(Component)
+     */
+    @Override
+    public Component add(String s, Component comp) {
+        return add(comp);
+    }
+    
+    /**
+     * Delegates to {@link #add(Component)}.
+     * @see DesktopFrame#add(Component)
+     */
+    @Override
+    public Component add(Component comp, int index) {
+    	//Delegate to add(Component comp) method
+        return add(comp);
+    }
+    
+    /**
+     * Delegates to {@link #add(Component)} - except for
+     * the addition of the {@link JRootPane}
+     * @see DesktopFrame#add(Component)
+     */
+    @Override
+    public void add(Component comp, Object constraints) {
+        if(JRootPane.class.isAssignableFrom(comp.getClass())) {
+            super.add(comp, constraints);
+            return;
+        }
+        //Delegate to add(Component comp) method
+        add(comp);
+    }
+
+    /**
+     * Delegates to {@link #add(Component)}.
+     * @see DesktopFrame#add(Component)
+     */
+    @Override
+    public void add(Component comp, Object constraints, int index) {
+    	//Delegate to add(Component comp) method
+    	add(comp);
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#WEST})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setLeftBorderComponent(JComponent c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.leftBorderComponent = c;
+        mainContentPanel.add(leftBorderComponent, BorderLayout.WEST);
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#EAST})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setRightBorderComponent(JComponent c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.rightBorderComponent = c;
+        mainContentPanel.add(rightBorderComponent, BorderLayout.EAST);
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#SOUTH})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setBottomBorderComponent(JComponent c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.bottomBorderComponent = c;
+        mainContentPanel.add(bottomBorderComponent, BorderLayout.SOUTH);
+    }
+    
+    /**
+     * Sets the flag indicating whether borders should be painted around this frame.
+     * Additionally, the user may also specify whether the default borders should 
+     * be installed.
+     * 
+     * @param b						border decorated flag.
+     * @param useDefaultBorders		flag indicating the desire to use the default 
+     * 								borders.
+     */
+    public void setBorderDecorated(boolean b, boolean useDefaultBorders) {
+        this.isBorderDecorated = b;
+        if(useDefaultBorders) {
+            installDefaultBorders();
+        }
+    }
+    
+    /**
+     * Returns the bounding rectangle relative to screen coordinates.
+     * 
+     * @return  the bounding rectangle relative to screen coordinates.
+     */
+    public Rectangle getBoundsOnScreen() {
+        return getBounds();
+    }
+    
+    @Override
+    public void paint(Graphics g) {
+    	super.paint(g);
+    	
+    }
+    
+    /**
+     * Initializes the border component sizes.
+     */
+    private void reshapeBorders() {
+        if(isBorderDecorated) {
+            if(leftBorderComponent != null) {
+                leftBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(rightBorderComponent != null) {
+                rightBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(bottomBorderComponent != null) {
+                bottomBorderComponent.setPreferredSize(new Dimension(getPreferredSize().width, borderSize));
+            }
+            mainContentPanel.revalidate();
+            mainContentPanel.repaint();
+        }
+    }
+    
+    /**
+     * Creates and returns the default title bar used if
+     * no user-specified title bar has been set.
+     * 
+     * @return  the default title bar
+     */
+    private TitleBar createTitleBar() {
+    	TitleBar titleBar = new DefaultTitleBar();
+        titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+        titleBar.setAlignmentX(Component.LEFT_ALIGNMENT);
+        
+        TitleBarControl control = createDefaultTitleBarControl();
+        control.setPreferredSize(new Dimension(60,20));
+        titleBar.addTitleBarControl(control);
+        
+        return titleBar; 
+    }
+    
+    /**
+     * Sets the title shown in this frame's titlebar.
+     * 
+     * @param	title	the frame's title
+     */
+    @Override
+    public void setTitle(String title) {
+        super.setTitle(title);
+        if(titleBar != null) {
+        	titleBar.setTitle(title);
+        	titleBar.repaint();
+        }
+    }
+    
+    /**
+     * Adds the JPanel which houses the main content.
+     * 
+     * @param panel The JPanel which houses the main content.
+     */
+    private void addMainContentPanel(JPanel panel) {
+        this.mainContentPanel = panel;
+        this.mainContentPanel.setOpaque(true);
+        super.add(mainContentPanel, BorderLayout.CENTER);
+    }
+    
+   /**
+     * Creates and returns the panel which holds the main content.
+     * 
+     * @return  the panel which holds the main content.
+     */
+    private JPanel createMainContentPanel() {
+        return new JPanel(new BorderLayout()) {
+        	@Override
+        	public void paintChildren(Graphics g) {
+        		if(isResizing) {
+    	    		Rectangle r = g.getClipBounds();
+        	    	storedImage = new BufferedImage(r.width, r.height, BufferedImage.TYPE_INT_ARGB);
+        	    	Graphics2D g2 = (Graphics2D)storedImage.getGraphics();
+        	    	super.paintChildren(g2);
+        	    	g2.dispose();
+    	    	}
+        		super.paintChildren(g);
+        	}
+        	@Override
+        	public void paintComponent(Graphics g) {
+        		if(isDragging) {
+            		g.drawImage(storedImage,0,0,null);
+            	}else {
+        	    	super.paintComponent(g);
+            	}
+        	}
+        };
+    }
+    
+    /**
+     * Installs default border components.
+     */
+    private void installDefaultBorders() {
+        JComponent lBorder = new JPanel();
+        lBorder.setBackground(getBorderColor());
+        setLeftBorderComponent(lBorder);
+        
+        JComponent rBorder = new JPanel();
+        rBorder.setBackground(getBorderColor());
+        setRightBorderComponent(rBorder);
+        
+        JComponent bBorder = new JPanel();
+        bBorder.setBackground(getBorderColor());
+        setBottomBorderComponent(bBorder);
+    }
+    
+    /**
+     * Installs the handler which controls the cursor changes
+     * for border or titlebar mouse overs.
+     */
+    private void addCursorHandler() {
+    	if(cursorHandlerInstalled()) return;
+    	
+    	cursorManager = new CursorManager();
+        titleBar.addMouseListener(cursorManager);
+        titleBar.addMouseMotionListener(cursorManager);
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(cursorManager);
+            leftBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(cursorManager);
+            rightBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(cursorManager);
+            bottomBorderComponent.addMouseMotionListener(cursorManager);
+        }
+    }
+    
+    /**
+     * Checks for the prior installation of the {@link DesktopFrame.CursorManager}.
+     * 
+     * @return	true if already installed, false if not.
+     */
+    private boolean cursorHandlerInstalled() {
+    	MouseListener[] installedListeners = titleBar.getMouseListeners();
+    	for(MouseListener l : installedListeners) {
+    		if(l instanceof CursorManager) {
+    			return true;
+    		}
+    	}
+    	return false;
+    }
+    
+    /**
+     * Installs the main mouse controller which handles the frame movement, etc.
+     * @param manager	
+     */
+    public void installMouseHandler(MouseHandler manager) {
+        titleBar.addMouseListener(manager);
+        titleBar.addMouseMotionListener(manager);
+        
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(manager);
+            leftBorderComponent.addMouseMotionListener(manager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(manager);
+            rightBorderComponent.addMouseMotionListener(manager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(manager);
+            bottomBorderComponent.addMouseMotionListener(manager);
+        }
+    }
+    
+    /**
+     * Uninstalls the mouse controller.
+     */
+    public void uninstallMouseHandler(MouseHandler manager) {
+        titleBar.removeMouseListener(manager);
+        titleBar.removeMouseMotionListener(manager);
+        if(leftBorderComponent != null) {
+            leftBorderComponent.removeMouseListener(manager);
+            leftBorderComponent.removeMouseMotionListener(manager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.removeMouseListener(manager);
+            rightBorderComponent.removeMouseMotionListener(manager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.removeMouseListener(manager);
+            bottomBorderComponent.removeMouseMotionListener(manager);
+        }
+    }
+    
+    /**
+     * Dynamically alters the cursor being displayed depending on the
+     * current mouse location.
+     * 
+     * @param side
+     */
+    private void setCursorForSide(Side side) {
+        switch(side) {
+            case N : setCursor(Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR)); break;
+            case W : setCursor(Cursor.getPredefinedCursor(Cursor.W_RESIZE_CURSOR)); break;
+            case S : setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR)); break;
+            case E : setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR)); break;
+            case NW : setCursor(Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR)); break;
+            case NE : setCursor(Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR)); break;
+            case SW : setCursor(Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR)); break;
+            case SE : setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR)); break;
+            default : setCursor(Cursor.getDefaultCursor());
+        }
+    }
+    
+    /**
+     * Class which listens to mouse movements and alters the cursor to 
+     * the appropriate cursor for the given mouse location.
+     * 
+     * @author David Ray
+     */
+    class CursorManager extends MouseInputAdapter {
+        private boolean isPressed;
+        
+        public void mouseMoved(MouseEvent m) {
+            Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+            setCursorForSide(side);
+         }
+        
+        public void mouseExited(MouseEvent m) {
+            if(!isPressed) {
+            	setCursor(Cursor.getDefaultCursor());
+            }
+        }
+        
+        public void mousePressed(MouseEvent m) {
+            isPressed = true;
+            Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+            setCursorForSide(side);
+        }
+        
+        public void mouseReleased(MouseEvent m) {
+            isPressed = false;
+            setCursor(Cursor.getDefaultCursor());
+        }
+    }
+    
+    /**
+     * Returns a flag indicating whether this frame is set to
+     * be maximizable.
+     * @return  flag indicating whether this frame is set to
+     * be maximizable.
+     */
+    public boolean isMaximizable() {
+        return true;
+    }
+    
+    /**
+     * Returns a flag indicating whether this frame is set to
+     * be iconifiable.
+     * @return  flag indicating whether this frame is set to
+     * be iconifiable.
+     */
+    public boolean isIconifiable() {
+        return true;
+    }
+    
+    private TitleBarControl createDefaultTitleBarControl() {
+    	return new DefaultTitleBarControl();
+    }
+    
+    /**
+     * Used internally to denote the sides of this frame.
+     */
+    private enum Side {
+        N(0,-1), W(-1,0), S(0,1), E(1,0), NW(-1,-1), NE(1,-1), SW(-1,1), SE(1,1), NONE(0,0);
+        
+        private int h;
+        private int v;
+        
+        private Side(int horizontal, int vertical) {
+            this.h = horizontal;
+            this.v = vertical;
+        }
+        
+        public static Side sideFor(Rectangle r, Point p, int margin) {
+            int horiz = 0;
+            int vert = 0;
+            margin += 2;
+            if(p.x >= r.x && p.x <= r.x + margin) horiz = -1;
+            else if(p.x >= r.getMaxX() - margin && p.x <= r.getMaxX()) horiz = 1;
+            if(p.y >= r.y && p.y <= r.y + margin) vert = -1;
+            else if(p.y >= (r.getMaxY() - margin) && p.y <= r.getMaxY()) vert = 1;
+            
+            return sideFor(horiz, vert);
+        }
+        
+        public static Side sideFor(int horiz, int vert) {
+            for(Side s : values()) {
+                if(s.h == horiz && s.v == vert) return s;
+            }
+            return NONE;
+        }
+        
+        public int vertical() {
+        	return v;
+        }
+        
+        public int horizontal() {
+        	return h;
+        }
+    }
+    
+    /**
+     * Handles the mouse events to control frame dragging
+     */
+    class MouseHandler extends MouseAdapter implements MouseMotionListener {
+    	private Rectangle frameRect;
+    	private Point startPoint;
+    	private Side startSide;
+    	
+    	public MouseHandler() {
+    		
+    	}
+    	
+    	@Override
+    	public void mousePressed(MouseEvent m) {
+    		frameRect = getBounds();
+    		startPoint = MouseInfo.getPointerInfo().getLocation();
+    		startSide = Side.sideFor(getBounds(), startPoint, resizeMargin);
+    		
+    		if(titleBar.isControlHit(m)) {
+    			titleBar.mousePressed(m);
+    		}
+    	}
+    	
+    	public void mouseDragged(MouseEvent m) {
+    		isDragging = true;
+    		Point p = MouseInfo.getPointerInfo().getLocation();
+    		
+    		int xAmount = (p.x - startPoint.x);
+    		int yAmount = (p.y - startPoint.y);
+    		DesktopFrame.this.isResizing = !isMoveOp(startSide);
+    		
+    		Rectangle prev = frameRect;
+    		frameRect = DesktopFrame.this.isResizing ? 
+    			resizeRectangle(frameRect, startSide, xAmount, yAmount) :
+    				moveRectangle(frameRect, xAmount, yAmount);
+    			
+    		setBounds(frameRect);
+    		fireWindowDragged(prev.getLocation(), frameRect.getLocation());
+    		startPoint = p;
+    	}
+    	
+    	public void mouseReleased(MouseEvent m) {
+    		isDragging = false;
+    		if(titleBar.isControlHit(m)) {
+    			titleBar.mouseReleased(m);
+    		}
+    		
+    		fireDraggingStopped();
+    	}
+    	
+    	private Rectangle moveRectangle(Rectangle r, int xAmount, int yAmount) {
+    		Rectangle rect = new Rectangle(r);
+    		rect.setLocation(rect.x + xAmount, rect.y + yAmount);
+    		return rect;
+    	}
+    	
+    	private Rectangle resizeRectangle(Rectangle r, Side side, int deltaX, int deltaY) {
+    		Rectangle rect = new Rectangle(r);
+    		if(side.vertical() != 0 || side.horizontal() != 0) {
+    			if(side.vertical() == -1) {
+    				resizeTopTo(rect, r.y + deltaY);
+    			}else if(side.vertical() == 1) {
+    				resizeBottomTo(rect, (int)r.getMaxY() + deltaY);
+    			}
+    			
+    			if(side.horizontal() == -1) {
+    				resizeLeftTo(rect, r.x + deltaX);
+    			}else if(side.horizontal() == 1) {
+    				resizeRightTo(rect, (int)r.getMaxX() + deltaX);
+    			}
+    		}
+    		return rect;
+    	}
+    	
+    	private boolean isMoveOp(Side side) {
+    		return side == Side.NONE;
+    	}
+    	
+    	private void resizeLeftTo(Rectangle r, int x) {
+    		int sourceX = r.x;
+    		r.width -= (x - sourceX);
+    		r.x = x;
+    	}
+    	
+    	private void resizeRightTo(Rectangle r, int x) {
+    		int sourceX = (int)r.getMaxX();
+    		r.width += (x - sourceX);
+    	}
+    	
+    	private void resizeTopTo(Rectangle r, int y) {
+    		int sourceY = r.y;
+    		r.height -= (y - sourceY);
+    		r.y = y;
+    	}
+    	
+    	private void resizeBottomTo(Rectangle r, int y) {
+    		int sourceY = (int)r.getMaxY();
+    		r.height += (y - sourceY);
+    	}
+    }
+    
+    /**
+     * Class which represents the controls on a given title bar such as 
+     * minimize, maximize, and close.
+     * 
+     * @author David Ray
+     *@see TitleBarControl
+     */
+    class DefaultTitleBarControl extends TitleBarControl {
+    	private static final int SIDE_MARGIN = 10;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public DefaultTitleBarControl() {
+    		createControlShapes();
+    		
+    		addMouseListener(new MouseAdapter() {
+    			public void mousePressed(MouseEvent e) {
+    				if(minimizeRect.contains(e.getPoint())) {
+    					setExtendedState(ICONIFIED);
+    				}
+    				if(maximizeRect.contains(e.getPoint())) {
+    					if((getExtendedState() & MAXIMIZED_BOTH) == MAXIMIZED_BOTH) {
+    						setExtendedState(NORMAL);
+    					}else{
+    						setExtendedState(MAXIMIZED_BOTH);
+    					}
+    				}
+    				if(closeRect.contains(e.getPoint())) {
+    					System.exit(0);
+    				}
+    			}
+    		});
+    	}
+    	@Override
+    	public void paintComponent(Graphics g) {
+    		if(!shapesInitialized) {
+    			createControlShapes();
+    			shapesInitialized = true;
+    		}
+    		
+    		Graphics2D g2 = (Graphics2D)g;
+    		g2.setColor(Color.BLACK);
+    		
+    		g2.setStroke(new BasicStroke(2));
+    		g2.drawLine((int)minimizeRect.getX(), (int)minimizeRect.getMaxY() - 3, 
+    			(int)minimizeRect.getMaxX() - 3, (int)minimizeRect.getMaxY() - 3);
+    		
+    		g2.draw(new Rectangle2D.Double(maximizeRect.getX() + 3, maximizeRect.getY() + 3, maximizeRect.getWidth() - 6, maximizeRect.getHeight() - 6));
+    		
+    		g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getY() + 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getMaxY() - 3);
+    		g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getMaxY() - 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getY() + 3);
+    	}
+    	
+    	private void createControlShapes() {
+    		int y = (getHeight() - 15) / 2;
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 15, 15);
+    		maximizeRect = new Rectangle2D.Double(SIDE_MARGIN + 16, y, 15, 15);
+    		closeRect = new Rectangle(SIDE_MARGIN + 32, y, 15, 15);
+    	}
+    }
+    
+    /**
+     * Creates a default {@link TitleBar}.
+     */
+    class DefaultTitleBar extends TitleBar {
+    	@Override
+		protected void paintTitle(Graphics2D g2) {
+			FontMetrics fm = g2.getFontMetrics();
+	        int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+	        g2.setColor(Color.BLACK);
+	        Rectangle r = g2.getClipBounds();
+	        int textX = (r.width - titleWidth) / 2;
+	        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+	        g2.drawString(title, textX, textY);
+		}
+
+		@Override
+		protected void fillTitleBar(Graphics2D g2) {
+			g2.setColor(Color.LIGHT_GRAY);
+			g2.fillRect(0, 0, getWidth(), getHeight());
+		}
+    }
+    
+    /**
+     * Defines methods which make available notifications regarding
+     * the stop and start of drag operations.
+     */
+    public static interface DragListener {
+    	public void windowDragged(Point oldLoc, Point newLoc);
+    	public void draggingStopped();
+    }
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java
new file mode 100644
index 0000000..1f880c2
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java
@@ -0,0 +1,292 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.LinearGradientPaint;
+import java.awt.Paint;
+import java.awt.RadialGradientPaint;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Stroke;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+
+
+@SuppressWarnings("serial")
+public class OSXTitleBar extends TitleBar {
+	
+	public OSXTitleBar() {
+		
+		addTitleBarControl(createTitleBarControl());
+	}
+	
+	@Override
+	protected void paintTitle(Graphics2D g2) {
+		FontMetrics fm = g2.getFontMetrics();
+        int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+        g2.setColor(Color.WHITE);
+        Rectangle r = g2.getClipBounds();
+        int textX = (r.width - titleWidth) / 2;
+        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+        g2.drawString(title, textX + 1, textY + 1);
+        g2.setColor(Color.BLACK);
+        g2.drawString(title, textX, textY);
+	}
+	
+	@Override
+	protected void fillTitleBar(Graphics2D g2) {
+		Paint oldPaint = g2.getPaint();
+        Stroke oldStroke = g2.getStroke();
+        
+        g2.setColor(new Color(241,241,241));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(0, 0, getWidth(), 0);
+        
+        LinearGradientPaint p = new LinearGradientPaint(
+        	1f, 1f, 1f, getHeight() - 1,
+        		new float[] { 0.0f, 0.499f, 0.5f, 1.0f },
+        			new Color[] { new Color(230, 230, 230), new Color(202, 202, 202),
+        				new Color(202, 202, 202), new Color(178, 178, 178) });
+        g2.setPaint(p);
+        g2.fillRect(0, 0, getWidth(), this.getHeight() - 1);
+        
+        
+        g2.setPaint(oldPaint);
+        g2.setColor(new Color(104, 104, 104));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(getX(), getHeight() - 1, getWidth(), getHeight() - 1);
+        
+        g2.setStroke(oldStroke);
+	}
+	
+	private TitleBarControl createTitleBarControl() {
+		OSXTitleBarControl control = new OSXTitleBarControl();
+		control.setPreferredSize(new Dimension(60,20));
+		control.setControlLocation(TitleBar.Location.LEFT);
+		return control;
+	}
+	
+	class OSXTitleBarControl extends TitleBarControl {
+		private static final int SIDE_MARGIN = 8;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean mouseOverClose;
+    	
+    	private JFrame hostFrame;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public OSXTitleBarControl() {
+    		createControlShapes();
+    		
+    		getParentFrame();
+    	}
+    	
+    	@Override
+    	public void paintComponent(Graphics graphics) {
+    		Graphics2D g = (Graphics2D)graphics;
+    		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+    		
+    		if(!shapesInitialized) {
+    			createControlShapes();
+    			shapesInitialized = true;
+    		}
+    		
+    		Graphics2D g2 = (Graphics2D)g;
+    		
+    		paintRedButton(g2);
+    		paintYellowButton(g2);
+    		paintGreenButton(g2);
+    	}
+    	
+    	private void paintRedButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)closeRect.getX(), (int)closeRect.getY() + 1, (int)closeRect.getWidth() - 1, (int)closeRect.getHeight());
+    		g2.setColor(new Color(134, 56, 51));
+    		g2.drawOval((int)closeRect.getX(), (int)closeRect.getY(), (int)closeRect.getWidth(), (int)closeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getCenterY()),
+    			(float)closeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(255,90,79), new Color(211,74,54) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getY() + (closeRect.getHeight() * 1.5) + 5),
+    			(float)closeRect.getWidth() - 2, new Point2D.Double(closeRect.getCenterX(), closeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 175), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getCenterY()), (float)closeRect.getWidth() * 1.5f,
+    			new Point2D.Double(closeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    		
+    		if(mouseOverClose) {
+    			g2.setColor(new Color(115, 84, 47));
+    			g2.setStroke(new BasicStroke(2));
+    			int third = (int)closeRect.getWidth() / 3;
+    			g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getY() + 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getMaxY() - 3);
+    			//g2.drawLine((int)closeRect.getX() + 5, (int)closeRect.getMaxY() + 5, (int)closeRect.getMaxX() - 5, (int)closeRect.getY() + 5);
+    			g2.draw(closeRect);
+    			g2.setStroke(oldStroke);
+    		}
+    	}
+    	
+    	private void paintYellowButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)minimizeRect.getX(), (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth() - 1, (int)minimizeRect.getHeight());
+    		g2.setColor(new Color(115, 84, 47));
+    		g2.drawOval((int)minimizeRect.getX(), (int)minimizeRect.getY(), (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getCenterY()),
+    			(float)minimizeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(238,202,99), new Color(237,166,72) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getY() + (minimizeRect.getHeight() * 1.5) + 5),
+    			(float)minimizeRect.getWidth() - 2, new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 250), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getCenterY()), (float)minimizeRect.getWidth() * 1.5f,
+    			new Point2D.Double(minimizeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    	}
+    	
+    	private void paintGreenButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)maximizeRect.getX(), (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth() - 1, (int)maximizeRect.getHeight());
+    		g2.setColor(new Color(74, 96, 59));
+    		g2.drawOval((int)maximizeRect.getX(), (int)maximizeRect.getY(), (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getCenterY()),
+    			(float)maximizeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(194,242,147), new Color(116,174,86) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getY() + (maximizeRect.getHeight() * 1.5) + 5),
+    			(float)maximizeRect.getWidth() - 2, new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 250), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getCenterY()), (float)maximizeRect.getWidth() * 1.5f,
+    			new Point2D.Double(maximizeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    	}
+    	
+    	private void createControlShapes() {
+    		int y = ((getHeight() - 10) / 2) - 1;
+    		closeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 10, 10);
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN + 20, y, 10, 10);
+    		maximizeRect = new Rectangle(SIDE_MARGIN + 40, y, 10, 10);
+    	}
+    	
+    	private void installListeners() {
+    		addMouseListener(new MouseAdapter() {
+    			public void mousePressed(MouseEvent e) {
+    				if(minimizeRect.contains(e.getPoint())) {
+    					hostFrame.setExtendedState(JFrame.ICONIFIED);
+    				}else if(maximizeRect.contains(e.getPoint())) {
+    					if((hostFrame.getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+    						hostFrame.setExtendedState(JFrame.NORMAL);
+    					}else{
+    						hostFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
+    					}
+    				}else if(closeRect.contains(e.getPoint())) {
+    					System.exit(0);
+    				}
+    			}
+    		});
+    		addMouseMotionListener(new MouseAdapter() {
+    			Rectangle2D localCloseRect = new Rectangle2D.Double(
+    				closeRect.getX() - 4, closeRect.getY() - 4, 
+    					closeRect.getWidth() + 8, closeRect.getHeight() + 8);
+    			Rectangle2D localMinimizeRect = new Rectangle2D.Double(
+    				minimizeRect.getX() - 4, minimizeRect.getY() - 4, 
+    					minimizeRect.getWidth() + 8, minimizeRect.getHeight() + 8);
+    			Rectangle2D localMaximizeRect = new Rectangle2D.Double(
+    				maximizeRect.getX() - 4, maximizeRect.getY() - 4, 
+    					maximizeRect.getWidth() + 8, maximizeRect.getHeight() + 8);
+    			public void mouseMoved(MouseEvent e) {
+    				if(localMinimizeRect.contains(e.getPoint())) {
+    					mouseOverClose = false;
+    				}else if(localMaximizeRect.contains(e.getPoint())) {
+    					mouseOverClose = false;
+    				}else if(localCloseRect.contains(e.getPoint())) {
+    					mouseOverClose = true;
+    				}else{
+    					mouseOverClose = false;
+    				}
+    				repaint();
+    			}
+    		});
+    	}
+    	
+    	private void getParentFrame() {
+    		(new Thread() {
+    			public void run() {
+    				while(hostFrame == null) {
+	    				try{ Thread.sleep(100); }catch(Exception e) { e.printStackTrace(); }
+	    				SwingUtilities.invokeLater(new Runnable() {
+	    					public void run() {
+	    						hostFrame = (JFrame)SwingUtilities.getAncestorOfClass(DesktopFrame.class, OSXTitleBarControl.this);
+	    					}
+	    				});
+    				}
+    				
+    				installListeners();
+    			}
+    		}).start();
+    	}
+	}
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
new file mode 100644
index 0000000..e9f204d
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
@@ -0,0 +1,93 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BorderLayout;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.RenderingHints;
+import java.awt.event.MouseEvent;
+
+import javax.swing.JPanel;
+
+@SuppressWarnings("serial")
+public abstract class TitleBar extends JPanel implements java.awt.event.MouseListener {
+	public enum Location { LEFT, CENTER, RIGHT };
+	
+	protected TitleBarControl control;
+	protected String title;
+	
+	public TitleBar() {
+		this("");
+	}
+	
+	public TitleBar(String title) {
+		this.title = title;
+		setLayout(new BorderLayout());
+	}
+	
+	public boolean isControlHit(MouseEvent m) {
+		if(control != null) {
+			return control.isControlHit(m);
+		}
+		return false;
+	}
+	
+	public void setTitle(String title) {
+		this.title = title;
+	}
+	
+	@Override
+	public void mousePressed(MouseEvent m) {
+		if(control == null) return;
+		control.mousePressed(m);
+	}
+	
+	@Override
+	public void mouseReleased(MouseEvent m) {
+		if(control == null) return;
+		control.mouseReleased(m);
+	}
+	
+	//NO-OP
+	@Override public void mouseClicked(MouseEvent e) {}
+	@Override public void mouseEntered(MouseEvent e) {}
+	@Override public void mouseExited(MouseEvent e) {}
+	
+	/**
+	 * Adds the component housing the window controls (i.e. minimize/maximize buttons)
+	 * to this {@code TitleBar}
+	 * 
+	 * @param c		Subclass of {@link TitleBarControl}
+	 */
+	public void addTitleBarControl(TitleBarControl c) {
+		if(this.control != null) {
+			remove(control);
+		}
+		
+		this.control = c;
+		switch(control.getControlLocation()) {
+			case LEFT: add(c, BorderLayout.WEST); break;
+			case CENTER: add(c, BorderLayout.CENTER); break;
+			case RIGHT : add(c, BorderLayout.EAST); break;
+		}
+	}
+	
+	@Override
+	public void paintComponent(Graphics g) {
+        super.paintComponent(g);
+        
+        Graphics2D g2 = (Graphics2D)g;
+        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        
+        fillTitleBar(g2);
+        
+        //if clip is for child(i.e. TitleBarControl) don't paint it now.
+        if(g2.getClipBounds().getSize().equals(getSize())) {
+        	paintTitle(g2);
+        }
+    }
+	
+	protected abstract void paintTitle(Graphics2D g2);
+	
+	protected abstract void fillTitleBar(Graphics2D g2);
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
new file mode 100644
index 0000000..a69d9da
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
@@ -0,0 +1,63 @@
+package org.apache.pivot.wtk;
+
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+import javax.swing.JComponent;
+
+
+
+/**
+ * Classes which are intended to provide titlebar control implementations 
+ * should be an extension of this class when used with the {@link DesktopFrame}
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public abstract class TitleBarControl extends JComponent implements MouseListener, MouseMotionListener {
+	private TitleBar.Location titleBarLoc = TitleBar.Location.RIGHT;
+	
+	@Override
+	public void mouseDragged(MouseEvent e) {}
+
+	@Override
+	public void mouseMoved(MouseEvent e) {}
+
+	@Override
+	public void mouseClicked(MouseEvent e) {}
+
+	@Override
+	public void mousePressed(MouseEvent e) {}
+
+	@Override
+	public void mouseReleased(MouseEvent e) {}
+
+	@Override
+	public void mouseEntered(MouseEvent e) {}
+
+	@Override
+	public void mouseExited(MouseEvent e) {}
+	
+	/**
+	 * Sets the title bar location, see {@link TitleBar.Location}
+	 * 
+	 * @param loc
+	 */
+	public void setControlLocation(TitleBar.Location loc) {
+		if(loc == null) throw new NullPointerException("location can not be null");
+		this.titleBarLoc = loc;
+	}
+
+	/**
+	 * Returns the {@link TitleBar.Location}
+	 * @return	the {@link TitleBar.Location} of the control
+	 */
+	public TitleBar.Location getControlLocation() {
+		return this.titleBarLoc;
+	}
+	
+	public boolean isControlHit(MouseEvent e) {
+		return this.getBounds().contains(e.getPoint());
+	}
+}
