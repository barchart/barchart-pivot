diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
index eb23b16..6b90237 100644
--- a/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopApplicationContext.java
@@ -192,6 +192,26 @@ public final class DesktopApplicationContext extends ApplicationContext {
             }
         }
     }
+    
+    /**
+     * Returns an {@link EventEnabledFrame} if the java version is greater
+     * than or equal to 7. The returned frame is capable of painting its own
+     * title bar so that move events on the frame (normally not able to
+     * be received), can be dispatched.
+     * 
+     * @return	an instance of EventEnabledFrame
+     */
+    protected static HostFrame getHostFrame() {
+    	if(isRunningVersion7OrGreater() && isUsingCustomFrame()) {
+    		System.out.println("Running extended capability pivot fork.2");
+    		String style = System.getProperty("windowStyle");
+    		if(style != null) {
+    			return new DesktopFrame(DesktopFrame.Style.styleFor(style));
+    		}
+    		return new DesktopFrame();
+    	}
+    	return new HostFrame();
+    }
 
     // The AWT Window class does not define a title property; this interface allows
     // the HostFrame and HostDialog titles to be handled polymorphically
@@ -201,11 +221,13 @@ public final class DesktopApplicationContext extends ApplicationContext {
     }
 
     // Native host frame
-    private static class HostFrame extends java.awt.Frame implements TitledWindow {
+    // David Ray : Forked change of access level (from private to protected) to this class and its extention
+    //			  to javax.swing.JFrame from java.awt.Frame
+    public static class HostFrame extends java.awt.Frame implements TitledWindow {
         private static final long serialVersionUID = 5340356674429280196L;
 
         public HostFrame() {
-            enableEvents(AWTEvent.WINDOW_EVENT_MASK
+        	enableEvents(AWTEvent.WINDOW_EVENT_MASK
                 | AWTEvent.WINDOW_STATE_EVENT_MASK);
 
             // Disable focus traversal keys
@@ -479,7 +501,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         boolean center = false;
         boolean resizable = true;
         boolean maximized = false;
-        boolean undecorated = false;
+        boolean undecorated = isRunningVersion7OrGreater() && isUsingCustomFrame();
         boolean fullScreen = false;
         boolean preserveSplashScreen = false;
 
@@ -564,7 +586,7 @@ public final class DesktopApplicationContext extends ApplicationContext {
         displays.add(primaryDisplayHost.getDisplay());
 
         // Create the windowed host frame
-        windowedHostFrame = new HostFrame();
+        windowedHostFrame = getHostFrame();
         windowedHostFrame.add(primaryDisplayHost);
         windowedHostFrame.setUndecorated(undecorated);
 
@@ -647,6 +669,28 @@ public final class DesktopApplicationContext extends ApplicationContext {
             });
         }
     }
+    
+    /**
+     * Called from the declaration of "undecorated" which calls
+     * {@link #isRunningVersion7OrGreater()} to determine if it is
+     * safe to create a custom barchart frame.
+     * 
+     * @return	flag indicating whether the java version is >= 1.7
+     */
+    private static boolean isRunningVersion7OrGreater() {
+    	String version = System.getProperty("java.version");
+    	return Integer.parseInt(version.split("\\.")[1]) >= 7;
+    }
+    
+    /**
+     * Returns a flag indicating whether the custom frame property was
+     * set to true on the command line
+     * @return	flag indicating the wish to use the custom frame
+     */
+    private static boolean isUsingCustomFrame() {
+    	String customProp = System.getProperty("requireCustomFrame");
+    	return customProp != null && customProp.trim().equalsIgnoreCase("true");
+    }
 
     private static void initializeOSExtensions() {
         String osName = System.getProperty("os.name");
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
new file mode 100644
index 0000000..0419d5b
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/DesktopFrame.java
@@ -0,0 +1,1137 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BasicStroke;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Cursor;
+import java.awt.Dimension;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.MouseInfo;
+import java.awt.Panel;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Toolkit;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.geom.Area;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+import javax.swing.SwingUtilities;
+
+
+
+/**
+ * Sub-class of {@link DesktopApplicationContext.HostFrame} which supports custom frame movement
+ * functionality
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public class DesktopFrame extends DesktopApplicationContext.HostFrame {
+	public enum Style { 
+		NATIVE_OSX, NATIVE_WIN, NATIVE_LINUX, CUSTOM, DEFAULT;
+		
+		public void apply(DesktopFrame frame) {
+			frame.configuredStyle = this;
+			
+			switch(this) {
+		        case NATIVE_LINUX:
+		        case NATIVE_WIN: {
+		        	frame.titleBarHeight = WIN_TITLEBAR_HEIGHT;
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		        	
+		        	frame.setBorderColor(Color.GRAY);
+		            frame.setBorderDecorated(true, true);
+		            frame.setBorderSize(5);
+		            
+		            frame.installWindowsBorders();
+		            
+		        	frame.reshapeBorders();
+		        	frame.mainContentPanel.invalidate();
+		        	break;
+		        }
+		        case NATIVE_OSX: {
+		        	frame.titleBarHeight = OSX_TITLEBAR_HEIGHT;
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		            frame.setBorderDecorated(true, true);
+		            frame.setBorderSize(1);
+		            frame.reshapeBorders();
+		        	break;
+		        }
+		        case CUSTOM: {
+		        	//break;
+		        }
+		        default: {
+		        	frame.titleBarHeight = DEFAULT_TITLEBAR_HEIGHT;
+		        	frame.setTitleBar(frame.createTitleBar(this));
+		            frame.setBorderDecorated(true, true);
+		            break;
+		        }
+	        }
+			
+			if(frame.titleBar != null) {
+				frame.addCursorHandler();
+		        frame.installMouseHandler(frame.new MouseHandler());
+		        TitleBarControl tbc =  frame.titleBar.getTitleBarControl();
+		        if(tbc != null) {
+		        	frame.titleBar.invalidate();
+		        	tbc.invalidate();
+		        	tbc.repaint();
+		        }
+		       
+		        frame.repaint();
+			}
+		}
+		
+		public static Style styleFor(String styleString) {
+			if(styleString == null) {
+				return null;
+			}
+			if(styleString.equalsIgnoreCase("osx")) {
+				return Style.NATIVE_OSX;
+			}else if(styleString.equalsIgnoreCase("win")) {
+				return Style.NATIVE_WIN;
+			}else if(styleString.equalsIgnoreCase("linux")) {
+				return Style.NATIVE_LINUX;
+			}
+			return null;
+		}
+	};
+	private static final int OSX_TITLEBAR_HEIGHT = 22;
+	private static final int WIN_TITLEBAR_HEIGHT = 30;
+	private static final int DEFAULT_TITLEBAR_HEIGHT = 25;
+	private static boolean NATIVE_STYLE_OVERRIDE;
+	
+	/** The size in pixels of the border */
+    private int borderSize = 1;
+    /** The thickness over which a cursor change will be triggered for resizing */
+    private int resizeMargin = borderSize;
+    /** The default height of the title bar */
+    private int titleBarHeight;
+    /** The Component shown as the title bar decoration */
+    private TitleBar titleBar;
+    /** The border color */
+    private Color borderColor = new Color(120, 120, 120);
+    /** Flag indicating this frame contains borders. */
+    private boolean isBorderDecorated;
+    /** Enum which handles the native os look and feel configuration */
+    private Style configuredStyle;
+    /** Flag indicating a resize operation ocurring */
+    private boolean isResizing;
+    /** Handles cursor changes to indicated resizing */
+    private CursorManager cursorManager;
+    /** The left border component which detects mouse events for cursor manipulation and resizing */
+    private Component leftBorderComponent;
+    /** The right border component which detects mouse events for cursor manipulation and resizing */
+    private Component rightBorderComponent;
+    /** The bottom border component which detects mouse events for cursor manipulation and resizing */
+    private Component bottomBorderComponent;
+    /** Houses the component added to this frame by the user */
+    private Container mainContentPanel;
+    /** List of listeners with interest in drag notifications */
+    private List<DragListener> dragListeners = new ArrayList<DragListener>();
+    /** List of screen rectangles - one per monitor */
+    private List<Rectangle> virtualDeviceBounds;
+    /** The shape of the virtual screens */
+    private Area virtualArea;
+    
+	
+	public DesktopFrame() {
+		this(NATIVE_STYLE_OVERRIDE ? Style.CUSTOM : getNativeStyle());
+	}
+	
+	public DesktopFrame(Style style) {
+		setUndecorated(true);
+		
+		setLayout(new BorderLayout());
+		
+		Panel panel = createMainContentPanel();
+		addMainContentPanel(panel);
+		
+		style.apply(this);
+		
+		//Collect the current monitor configuration boundaries.
+        getEnvironmentInfo(); 
+	}
+	
+	@Override
+	public Component add(Component comp) {
+		mainContentPanel.add(comp, BorderLayout.CENTER);
+		return comp;
+	}
+	
+	@Override
+	public void update(Graphics g) {
+		paint(g);
+	}
+	
+	/**
+     * Protects against a frame location being out of aggregate
+     * device bounds by repositioning the upper left corner of a
+     * frame that is out of virtual device bounds to be within
+     * the bounds of the closest screen.
+     * 
+     * @param p		the location in question
+     * @return		the most ideal location, or the same point if
+     * 				that point is location within virtual device
+     * 				bounds.
+     */
+    private Point getValidLocationFor(Point p) {
+    	if(virtualDeviceBounds == null) {
+    		return p;
+    	}
+    	
+    	if(!virtualArea.contains(p)) {
+    		Rectangle r = getClosestDevice(p);
+    		p.x = Math.max(r.x, p.x);
+			p.x = Math.min((int)r.getMaxX(), p.x);
+			p.y = Math.max(r.y, p.y);
+			p.y = Math.min((int)r.getMaxY(), p.y);
+    	}
+    	return p;
+    }
+    
+    /**
+     * Called when the suggested location passed in by 
+     * the windowing environment (read Pivot) is outside
+     * the device bounds described by the combined graphics
+     * devices. This happens for sure with Mac OSX due to 
+     * the existence of the MenuBar on top.
+     * 
+     * @param p
+     * @return		the bounds of the closest screen relative 
+     * 				to the {@link Point} passed in.
+     */
+    private Rectangle getClosestDevice(Point p) {
+    	double distance = Integer.MAX_VALUE;
+    	Rectangle closest = null;
+    	for(Rectangle r : virtualDeviceBounds) {
+    		if(p.distance(r.getLocation()) < distance) {
+    			closest = r;
+    			distance = p.distance(r.getLocation());
+    		}
+    	}
+    	return closest;
+    }
+	
+	/**
+     * Sets the location of this {@link TempFrame}
+     * 
+     * Native frames would know their screen bounds, but 
+     * because this is a custom frame, we must intercept this
+     * call to make sure that the location is a valid one.
+     * 
+     * @param	x	x location
+     * @param	y   y location
+     * 
+     */
+    @Override
+    public void setLocation(int x, int y) {
+    	Point p = getValidLocationFor(new Point(x, y));
+    	super.setLocation(p.x, p.y);
+    }
+    
+    /**
+     * Sets the location of this {@link TempFrame}
+     * 
+     * Native frames would know their screen bounds, but 
+     * because this is a custom frame, we must intercept this
+     * call to make sure that the location is a valid one.
+     * 
+     * @param	p	the location of this frame as a {@link Point}
+     */
+    @Override
+    public void setLocation(Point p) {
+    	super.setLocation(getValidLocationFor(p));
+    }
+	
+	/**
+     * Returns the current component serving as the {@link TitleBar}
+     * 
+     * @return	the current component serving as the {@link TitleBar}
+     */
+    public TitleBar getTitleBar() {
+    	return this.titleBar;
+    }
+	
+	/**
+     * Called by the SwingContainer class to determine the location
+     * to set on the delegate Window.
+     * @return
+     */
+    public java.awt.Insets getTitlebarInsets() {
+    	java.awt.Insets superInsets = super.getInsets();
+    	if(titleBar == null) {
+    		return superInsets;
+    	}
+    	return new java.awt.Insets(
+    		titleBar.getPreferredSize().height, superInsets.left + leftBorderComponent.getWidth(), 
+    			superInsets.bottom + bottomBorderComponent.getHeight(), superInsets.right + rightBorderComponent.getWidth());
+    }
+	
+	/**
+     * Installs the handler which controls the cursor changes
+     * for border or titlebar mouse overs.
+     */
+    private void addCursorHandler() {
+    	if(cursorHandlerInstalled() || titleBar == null) return;
+    	
+    	cursorManager = new CursorManager();
+        titleBar.addMouseListener(cursorManager);
+        titleBar.addMouseMotionListener(cursorManager);
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(cursorManager);
+            leftBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(cursorManager);
+            rightBorderComponent.addMouseMotionListener(cursorManager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(cursorManager);
+            bottomBorderComponent.addMouseMotionListener(cursorManager);
+        }
+    }
+    
+    /**
+     * Installs the main mouse controller which handles the frame movement, etc.
+     * @param manager	
+     */
+    public void installMouseHandler(MouseHandler manager) {
+        titleBar.addMouseListener(manager);
+        titleBar.addMouseMotionListener(manager);
+        
+        if(leftBorderComponent != null) {
+            leftBorderComponent.addMouseListener(manager);
+            leftBorderComponent.addMouseMotionListener(manager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.addMouseListener(manager);
+            rightBorderComponent.addMouseMotionListener(manager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.addMouseListener(manager);
+            bottomBorderComponent.addMouseMotionListener(manager);
+        }
+    }
+    
+    /**
+     * Checks for the prior installation of the {@link TempFrame.CursorManager}.
+     * 
+     * @return	true if already installed, false if not.
+     */
+    private boolean cursorHandlerInstalled() {
+    	if(titleBar != null) {
+	    	MouseListener[] installedListeners = titleBar.getMouseListeners();
+	    	for(MouseListener l : installedListeners) {
+	    		if(l instanceof CursorManager) {
+	    			return true;
+	    		}
+	    	}
+    	}
+    	return false;
+    }
+    
+    /**
+     * Adds the JPanel which houses the main content.
+     * 
+     * @param panel The JPanel which houses the main content.
+     */
+    private void addMainContentPanel(Panel panel) {
+        this.mainContentPanel = panel;
+        super.add(mainContentPanel, BorderLayout.CENTER);
+    }
+    
+   /**
+     * Creates and returns the panel which holds the main content.
+     * 
+     * @return  the panel which holds the main content.
+     */
+    private Panel createMainContentPanel() {
+        Panel main = new Panel() {
+        	@Override
+        	public void paint(Graphics g) {
+        		super.paint(g);
+        		if(configuredStyle == Style.NATIVE_WIN) {
+        			Rectangle r = g.getClipBounds();
+        			
+            		g.setColor(Color.BLACK);
+            		g.drawLine(0,0,0,r.height);
+            		g.drawLine(0, r.height - 1, r.width, r.height - 1);
+            		g.drawLine(r.width - 1, 0, r.width - 1, r.height - 1);
+            	}
+        	}
+        	@Override
+        	public void update(Graphics g) {
+        		paint(g);
+        	}
+        };
+        main.setPreferredSize(new Dimension(300, 200));
+        main.setLayout(new BorderLayout());
+        return main;
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#WEST})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setLeftBorderComponent(Component c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.leftBorderComponent = c;
+        mainContentPanel.add(leftBorderComponent, BorderLayout.WEST);
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#EAST})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setRightBorderComponent(Component c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.rightBorderComponent = c;
+        mainContentPanel.add(rightBorderComponent, BorderLayout.EAST);
+    }
+    
+    /**
+     * Sets the component representing the left ({@link BorderLayout#SOUTH})
+     * frame border. All border components have a default which is automatically
+     * installed and can have their size and color altered. For any (more
+     * complex) painting, it is necessary for the user to install their own
+     * component (i.e. Gradients etc.)
+     * 
+     * @param c	the component painting the left border.
+     */
+    public void setBottomBorderComponent(Component c) {
+        if(!isBorderDecorated) {
+            throw new IllegalStateException("Please call setBorderDecorated(true) first.");
+        }
+        this.bottomBorderComponent = c;
+        mainContentPanel.add(bottomBorderComponent, BorderLayout.SOUTH);
+    }
+    
+    /**
+     * Checks the os system property for the current os and
+     * returns an enum specifying a style for that particular
+     * os.
+     * 
+     * @return	{@link Style}
+     */
+    private static Style getNativeStyle() {
+    	String osName = System.getProperty("os.name");
+
+        if (osName.toLowerCase(Locale.ENGLISH).startsWith("mac os x")) {
+        	return Style.NATIVE_OSX;
+        }else if(osName.toLowerCase(Locale.ENGLISH).startsWith("window")) {
+        	return Style.NATIVE_WIN;
+        }else if(osName.toLowerCase(Locale.ENGLISH).startsWith("linux")) {
+        	return Style.NATIVE_LINUX;
+        }
+        return Style.DEFAULT;
+    }
+	
+	/**
+     * If a custom style (i.e. non-native prebuilt style) is desired
+     * this method must be called with "true" before this frame
+     * is instantiated.
+     * 
+     * @param b
+     */
+    public static void overrideNativeStyle(boolean b) {
+    	DesktopFrame.NATIVE_STYLE_OVERRIDE = b;
+    }
+	
+	/**
+     * Returns a flag indicating whether this frame is set to
+     * be maximizable.
+     * @return  flag indicating whether this frame is set to
+     * be maximizable.
+     */
+    public boolean isMaximizable() {
+        return true;
+    }
+    
+    /**
+     * Returns a flag indicating whether this frame is set to
+     * be iconifiable.
+     * @return  flag indicating whether this frame is set to
+     * be iconifiable.
+     */
+    public boolean isIconifiable() {
+        return true;
+    }
+    
+    /**
+     * Sets the flag indicating whether borders should be painted around this frame.
+     * Additionally, the user may also specify whether the default borders should 
+     * be installed.
+     * 
+     * @param b						border decorated flag.
+     * @param useDefaultBorders		flag indicating the desire to use the default 
+     * 								borders.
+     */
+    public void setBorderDecorated(boolean b, boolean useDefaultBorders) {
+        this.isBorderDecorated = b;
+        if(useDefaultBorders) {
+            installDefaultBorders();
+        }
+    }
+    
+    /**
+     * Installs default border components.
+     */
+    private void installDefaultBorders() {
+        Panel lBorder = new Panel();
+        lBorder.setBackground(getBorderColor());
+        setLeftBorderComponent(lBorder);
+        
+        Panel rBorder = new Panel();
+        rBorder.setBackground(getBorderColor());
+        setRightBorderComponent(rBorder);
+        
+        Panel bBorder = new Panel();
+        bBorder.setBackground(getBorderColor());
+        setBottomBorderComponent(bBorder);
+    }
+    
+    /**
+     * Called from {@link Style#apply(TempFrame)} to
+     * install native Windows os look and feel to this
+     * frame.
+     */
+    private void installWindowsBorders() {
+    	removeBorders();
+    	
+    	Component lBorder = new Panel() {
+    		@Override
+    		public void paint(Graphics g) {
+    			super.paint(g);
+    			Rectangle r = g.getClipBounds();
+    			g.setColor(getBorderColor());
+    			g.fillRect(r.x, r.y, r.width, r.height);
+    			g.setColor(Color.WHITE);
+        		g.drawLine(1,0,1,r.height);
+    		}
+    		@Override
+    		public void update(Graphics g) {
+    			paint(g);
+    		}
+    	};
+        lBorder.setBackground(getBorderColor());
+    	setLeftBorderComponent(lBorder);
+        
+        Component rBorder = new Panel() {
+        	public void paint(Graphics g) {
+        		super.paint(g);
+        		Rectangle r = g.getClipBounds();
+        		g.setColor(getBorderColor());
+    			g.fillRect(r.x, r.y, r.width, r.height);
+        		g.setColor(Color.WHITE);
+        		g.drawLine(r.width - 2,0,r.width - 2,r.height - 1);
+        	}
+        	@Override
+        	public void update(Graphics g) {
+        		paint(g);
+        	}
+        };
+        rBorder.setBackground(getBorderColor());
+        setRightBorderComponent(rBorder);
+        
+        Component bBorder = new Panel() {
+        	@Override
+        	public void paint(Graphics g) {
+        		super.paint(g);
+        		Rectangle r = g.getClipBounds();
+        		g.setColor(getBorderColor());
+    			g.fillRect(r.x, r.y, r.width, r.height);
+        		g.setColor(Color.WHITE);
+        		g.drawLine(1,r.height - 2,r.width - 2,r.height - 2);
+        		g.drawLine(1, 0, 1, r.height - 2);
+        		g.drawLine(r.width - 2, 0, r.width - 2, r.height - 2);
+        	}
+        	@Override
+        	public void update(Graphics g) {
+        		paint(g);
+        	}
+        };
+        bBorder.setBackground(getBorderColor());
+        setBottomBorderComponent(bBorder);
+    }
+    
+    /**
+     * Removes the border components.
+     */
+    private void removeBorders() {
+    	removeBorderCursorHandlers();
+    	if(leftBorderComponent != null) {
+    		((Container)mainContentPanel).remove(leftBorderComponent);
+    		leftBorderComponent = null;
+    	}
+    	if(rightBorderComponent != null) {
+    		((Container)mainContentPanel).remove(rightBorderComponent);
+    		rightBorderComponent = null;
+    	}
+    	if(bottomBorderComponent != null) {
+    		((Container)mainContentPanel).remove(bottomBorderComponent);
+    		bottomBorderComponent = null;
+    	}
+    }
+    
+    /**
+     * Uninstalls the handler which manages cursors over the borders.
+     */
+    private void removeBorderCursorHandlers() {
+    	if(leftBorderComponent != null) {
+            leftBorderComponent.removeMouseListener(cursorManager);
+            leftBorderComponent.removeMouseMotionListener(cursorManager);
+        }
+        if(rightBorderComponent != null) {
+            rightBorderComponent.removeMouseListener(cursorManager);
+            rightBorderComponent.removeMouseMotionListener(cursorManager);
+        }
+        if(bottomBorderComponent != null) {
+            bottomBorderComponent.removeMouseListener(cursorManager);
+            bottomBorderComponent.removeMouseMotionListener(cursorManager);
+        }
+    }
+    
+    /**
+     * Sets the color that will be used to paint the border.
+     * @param c		the border color
+     */
+    public void setBorderColor(Color c) {
+        this.borderColor = c;
+    }
+    
+    /**
+     * Returns the color that is used to paint the border
+     * @return	the current border color
+     */
+    public Color getBorderColor() {
+        return borderColor;
+    }
+    
+    /**
+     * Sets the size in pixels of the frame border
+     * 
+     * @param size	the frame border size.
+     */
+    public void setBorderSize(int size) {
+        borderSize = size;
+        if(isDisplayable()) {
+            reshapeBorders();
+        }
+    }
+    
+    /**
+     * Returns the border size.
+     * @return	the border size.
+     */
+    public int getBorderSize() {
+        return borderSize;
+    }
+    
+    /**
+     * Initializes the border component sizes.
+     */
+    private void reshapeBorders() {
+        if(isBorderDecorated) {
+            if(leftBorderComponent != null) {
+                leftBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(rightBorderComponent != null) {
+                rightBorderComponent.setPreferredSize(new Dimension(borderSize, getPreferredSize().height - titleBarHeight));
+            }
+            if(bottomBorderComponent != null) {
+                bottomBorderComponent.setPreferredSize(new Dimension(getPreferredSize().width, borderSize));
+            }
+            invalidate();
+            repaint();
+        }
+    }
+    
+    /**
+     * Sets the height in pixels of the title bar.
+     * 
+     * @param height	the height of the title bar
+     */
+    public void setTitleBarHeight(int height) {
+        titleBarHeight = height;
+    }
+    
+    /**
+     * Returns the title bar height
+     * 
+     * @return	the current title bar height
+     */
+    public int getTitleBarHeight() {
+        return titleBarHeight;
+    }
+    
+    /**
+     * Creates and returns the default title bar used if
+     * no user-specified title bar has been set.
+     * 
+     * @return  the default title bar
+     */
+    private TitleBar createTitleBar(Style style) {
+    	TitleBar titleBar = null;
+    	switch(style) {
+	    	case NATIVE_LINUX:
+	    	case NATIVE_WIN: {
+	    		titleBar = new WindowsTitleBar();
+	    		titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+	            break;
+	    	}
+	    	case NATIVE_OSX: {
+	    		titleBar = new OSXTitleBar();
+	    		titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+	            break;
+	    	}
+	    	default: {
+	    		titleBar = new DefaultTitleBar();
+	    		titleBar.setPreferredSize(new Dimension(0, titleBarHeight));
+	            
+	            TitleBarControl control = createDefaultTitleBarControl();
+	            control.setPreferredSize(new Dimension(60,20));
+	            titleBar.addTitleBarControl(control);
+	            break;
+	    	}
+    	}
+    	
+    	return titleBar; 
+    }
+    
+    /**
+     * Creates the default title bar buttons.
+     * @return	the default title bar buttons.
+     */
+    private TitleBarControl createDefaultTitleBarControl() {
+    	return new DefaultTitleBarControl();
+    }
+    
+    /**
+     * Sets the title shown in this frame's titlebar.
+     * 
+     * @param	title	the frame's title
+     */
+    @Override
+    public void setTitle(String title) {
+        super.setTitle(title);
+        if(titleBar != null) {
+        	titleBar.setTitle(title);
+        	titleBar.repaint();
+        }
+    }
+    
+    /**
+     * Sets the {@link TitleBar} component.
+     * 
+     * The {@code TitleBar}'s preferred height must be set prior
+     * to calling this method (preferredWidth is irrelevant, i.e.
+     * can be set to zero).
+     * 
+     * @param c		the TitleBar component.
+     */
+    public void setTitleBar(TitleBar c) {
+    	removeTitleBar();
+        this.titleBar = c;
+        titleBarHeight = c.getPreferredSize().height;
+        add(c, BorderLayout.NORTH);
+        invalidate();
+        validate();
+        repaint();
+        titleBar.repaint();
+    }
+    
+    /**
+     * Removes the {@link TitleBar} component
+     */
+    public void removeTitleBar() {
+       Component c = titleBar;
+        if(c != null) {
+        	remove(c);
+        }
+        
+        this.titleBar = null;
+        setTitleBarHeight(0);
+        invalidate();
+        validate();
+        repaint();
+    }
+	
+	/**
+     * Used internally to denote the sides of this frame.
+     */
+    private enum Side {
+        N(0,-1), W(-1,0), S(0,1), E(1,0), NW(-1,-1), NE(1,-1), SW(-1,1), SE(1,1), NONE(0,0);
+        
+        private int h;
+        private int v;
+        
+        private Side(int horizontal, int vertical) {
+            this.h = horizontal;
+            this.v = vertical;
+        }
+        
+        public static Side sideFor(Rectangle r, Point p, int margin) {
+            int horiz = 0;
+            int vert = 0;
+            margin += 2;
+            if(p.x >= r.x && p.x <= r.x + margin) horiz = -1;
+            else if(p.x >= r.getMaxX() - margin && p.x <= r.getMaxX()) horiz = 1;
+            if(p.y >= r.y && p.y <= r.y + margin) vert = -1;
+            else if(p.y >= (r.getMaxY() - margin) && p.y <= r.getMaxY()) vert = 1;
+            
+            return sideFor(horiz, vert);
+        }
+        
+        public static Side sideFor(int horiz, int vert) {
+            for(Side s : values()) {
+                if(s.h == horiz && s.v == vert) return s;
+            }
+            return NONE;
+        }
+        
+        public int vertical() {
+        	return v;
+        }
+        
+        public int horizontal() {
+        	return h;
+        }
+    }
+    
+    /**
+     * Dynamically alters the cursor being displayed depending on the
+     * current mouse location.
+     * 
+     * @param side
+     */
+    private void setCursorForSide(Side side) {
+        switch(side) {
+            case N : setCursor(Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR)); break;
+            case W : setCursor(Cursor.getPredefinedCursor(Cursor.W_RESIZE_CURSOR)); break;
+            case S : setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR)); break;
+            case E : setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR)); break;
+            case NW : setCursor(Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR)); break;
+            case NE : setCursor(Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR)); break;
+            case SW : setCursor(Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR)); break;
+            case SE : setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR)); break;
+            default : setCursor(Cursor.getDefaultCursor());
+        }
+    }
+    
+    /**
+     * Adds the specified {@link DragListener} to this {@code DesktopFrame}
+     * @param d		the {@code DragListener} to add.
+     */
+    public void addDragListener(DragListener d) {
+    	if(d != null) {
+    		dragListeners.add(d);
+    	}
+    }
+    
+    /**
+     * Fires a window dragged event to registered listeners.
+     * 
+     * @param oldLoc
+     * @param newLoc
+     */
+    public void fireWindowDragged(Point oldLoc, Point newLoc) {
+    	for(DragListener l : dragListeners) {
+    		l.windowDragged(oldLoc, newLoc);
+    	}
+    }
+    
+    /**
+     * Fires an event notifiying {@link DragListener}s that
+     * dragging has stopped.
+     */
+    public void fireDraggingStopped() {
+    	for(DragListener l : dragListeners) {
+    		l.draggingStopped();
+    	}
+    }
+    
+    /**
+     * Gathers and stores information about the graphics environment
+     * such as the combined screen area of a multiscreen environment
+     * and the shape its bounding polygon.
+     */
+    private void getEnvironmentInfo() {
+    	 GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
+         GraphicsDevice[] gs = ge.getScreenDevices();
+         virtualDeviceBounds = new ArrayList<Rectangle>();
+         virtualArea = new Area();
+         for (int j = 0; j < gs.length; j++) {
+             GraphicsDevice gd = gs[j];
+             GraphicsConfiguration[] gc = gd.getConfigurations();
+             for (int i=0; i < gc.length; i++) {
+            	 Rectangle r = gc[i].getBounds();
+            	 java.awt.Insets screenInsets = Toolkit.getDefaultToolkit().getScreenInsets(gc[i]);
+            	 r.x = r.x + screenInsets.left;
+            	 r.y = r.y + screenInsets.top;
+            	 r.setSize(r.width - (screenInsets.left + screenInsets.right),
+            		r.height - (screenInsets.top + screenInsets.bottom));
+            	 virtualDeviceBounds.add(r);
+            	 virtualArea.add(new Area(r));
+             }
+         } 
+    }
+    
+    /**
+     * Class which listens to mouse movements and alters the cursor to 
+     * the appropriate cursor for the given mouse location.
+     * 
+     * @author David Ray
+     */
+    class CursorManager extends MouseAdapter {
+        private boolean isPressed;
+        
+        @Override
+        public void mouseMoved(MouseEvent m) {
+	       Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+	       setCursorForSide(side);
+	    }
+        @Override
+        public void mouseExited(MouseEvent m) {
+            if(!isPressed) {
+            	setCursor(Cursor.getDefaultCursor());
+            }
+        }
+        @Override
+        public void mousePressed(MouseEvent m) {
+            isPressed = true;
+            Side side = Side.sideFor(getBounds(), m.getLocationOnScreen(), resizeMargin);
+            setCursorForSide(side);
+        }
+        @Override
+        public void mouseReleased(MouseEvent m) {
+            isPressed = false;
+            setCursor(Cursor.getDefaultCursor());
+        }
+    }
+	
+	/**
+     * Handles the mouse events to control frame dragging
+     */
+    class MouseHandler extends MouseAdapter implements MouseMotionListener {
+    	private Rectangle frameRect;
+    	private Point startPoint;
+    	private Side startSide;
+    	
+    	public MouseHandler() {
+    		
+    	}
+    	
+    	@Override
+    	public void mousePressed(MouseEvent m) {
+    		frameRect = getBounds();
+    		startPoint = MouseInfo.getPointerInfo().getLocation();
+    		startSide = Side.sideFor(getBounds(), startPoint, resizeMargin);
+    		
+    		if(titleBar != null && titleBar.isControlHit(m)) {
+    			titleBar.mousePressed(m);
+    		}
+    	}
+    	
+    	public void mouseDragged(MouseEvent m) {
+    		Point p = MouseInfo.getPointerInfo().getLocation();
+    		
+    		int xAmount = (p.x - startPoint.x);
+    		int yAmount = (p.y - startPoint.y);
+    		DesktopFrame.this.isResizing = !isMoveOp(startSide);
+    		
+    		Rectangle prev = frameRect;
+    		frameRect = DesktopFrame.this.isResizing ? 
+    			resizeRectangle(frameRect, startSide, xAmount, yAmount) :
+    				moveRectangle(frameRect, xAmount, yAmount);
+    			
+    		setBounds(frameRect);
+    		fireWindowDragged(prev.getLocation(), frameRect.getLocation());
+    		startPoint = p;
+    	}
+    	
+    	public void mouseReleased(MouseEvent m) {
+    		if(titleBar != null && titleBar.isControlHit(m)) {
+    			titleBar.mouseReleased(m);
+    		}
+    		
+    		fireDraggingStopped();
+    	}
+    	
+    	private Rectangle moveRectangle(Rectangle r, int xAmount, int yAmount) {
+    		Rectangle rect = new Rectangle(r);
+    		rect.setLocation(rect.x + xAmount, rect.y + yAmount);
+    		return rect;
+    	}
+    	
+    	private Rectangle resizeRectangle(Rectangle r, Side side, int deltaX, int deltaY) {
+    		Rectangle rect = new Rectangle(r);
+    		if(side.vertical() != 0 || side.horizontal() != 0) {
+    			if(side.vertical() == -1) {
+    				resizeTopTo(rect, r.y + deltaY);
+    			}else if(side.vertical() == 1) {
+    				resizeBottomTo(rect, (int)r.getMaxY() + deltaY);
+    			}
+    			
+    			if(side.horizontal() == -1) {
+    				resizeLeftTo(rect, r.x + deltaX);
+    			}else if(side.horizontal() == 1) {
+    				resizeRightTo(rect, (int)r.getMaxX() + deltaX);
+    			}
+    		}
+    		return rect;
+    	}
+    	
+    	private boolean isMoveOp(Side side) {
+    		return side == Side.NONE;
+    	}
+    	
+    	private void resizeLeftTo(Rectangle r, int x) {
+    		int sourceX = r.x;
+    		r.width -= (x - sourceX);
+    		r.x = x;
+    	}
+    	
+    	private void resizeRightTo(Rectangle r, int x) {
+    		int sourceX = (int)r.getMaxX();
+    		r.width += (x - sourceX);
+    	}
+    	
+    	private void resizeTopTo(Rectangle r, int y) {
+    		int sourceY = r.y;
+    		r.height -= (y - sourceY);
+    		r.y = y;
+    	}
+    	
+    	private void resizeBottomTo(Rectangle r, int y) {
+    		int sourceY = (int)r.getMaxY();
+    		r.height += (y - sourceY);
+    	}
+    }
+    
+    /**
+     * Class which represents the controls on a given title bar such as 
+     * minimize, maximize, and close.
+     * 
+     * @author David Ray
+     *@see TitleBarControl
+     */
+    class DefaultTitleBarControl extends TitleBarControl {
+    	private static final int SIDE_MARGIN = 10;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public DefaultTitleBarControl() {
+    		createControlShapes();
+    		
+    		addMouseListener(new MouseAdapter() {
+    			public void mousePressed(MouseEvent e) {
+    				if(minimizeRect.contains(e.getPoint())) {
+    					setExtendedState(ICONIFIED);
+    				}
+    				if(maximizeRect.contains(e.getPoint())) {
+    					if((getExtendedState() & MAXIMIZED_BOTH) == MAXIMIZED_BOTH) {
+    						setExtendedState(NORMAL);
+    					}else{
+    						setExtendedState(MAXIMIZED_BOTH);
+    					}
+    				}
+    				if(closeRect.contains(e.getPoint())) {
+    					System.exit(0);
+    				}
+    			}
+    		});
+    	}
+    	@Override
+    	public void paint(Graphics g) {
+    		if(!shapesInitialized) {
+    			createControlShapes();
+    			shapesInitialized = true;
+    		}
+    		
+    		Graphics2D g2 = (Graphics2D)g;
+    		g2.setColor(Color.BLACK);
+    		
+    		g2.setStroke(new BasicStroke(2));
+    		g2.drawLine((int)minimizeRect.getX(), (int)minimizeRect.getMaxY() - 3, 
+    			(int)minimizeRect.getMaxX() - 3, (int)minimizeRect.getMaxY() - 3);
+    		
+    		g2.draw(new Rectangle2D.Double(maximizeRect.getX() + 3, maximizeRect.getY() + 3, maximizeRect.getWidth() - 6, maximizeRect.getHeight() - 6));
+    		
+    		g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getY() + 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getMaxY() - 3);
+    		g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getMaxY() - 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getY() + 3);
+    	}
+    	@Override
+    	public void update(Graphics g) {
+    		paint(g);
+    	}
+    	
+    	private void createControlShapes() {
+    		int y = (getHeight() - 15) / 2;
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 15, 15);
+    		maximizeRect = new Rectangle2D.Double(SIDE_MARGIN + 16, y, 15, 15);
+    		closeRect = new Rectangle(SIDE_MARGIN + 32, y, 15, 15);
+    	}
+    }
+    
+    /**
+     * Creates a default {@link TitleBar}.
+     */
+    class DefaultTitleBar extends TitleBar {
+    	@Override
+		protected void paintTitle(Graphics2D g2) {
+			FontMetrics fm = g2.getFontMetrics();
+	        int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+	        g2.setColor(Color.BLACK);
+	        Rectangle r = g2.getClipBounds();
+	        int textX = (r.width - titleWidth) / 2;
+	        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+	        g2.drawString(title, textX, textY);
+		}
+
+		@Override
+		protected void fillTitleBar(Graphics2D g2) {
+			g2.setColor(Color.LIGHT_GRAY);
+			g2.fillRect(0, 0, getWidth(), getHeight());
+		}
+    }
+    
+    /**
+     * Defines methods which make available notifications regarding
+     * the stop and start of drag operations.
+     */
+    public static interface DragListener {
+    	public void windowDragged(Point oldLoc, Point newLoc);
+    	public void draggingStopped();
+    }
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java
new file mode 100644
index 0000000..7d40e35
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/OSXTitleBar.java
@@ -0,0 +1,391 @@
+package org.apache.pivot.wtk;
+
+import java.awt.AWTEvent;
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.LinearGradientPaint;
+import java.awt.Paint;
+import java.awt.RadialGradientPaint;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Stroke;
+import java.awt.Toolkit;
+import java.awt.event.AWTEventListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.WindowEvent;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+
+
+@SuppressWarnings("serial")
+public class OSXTitleBar extends TitleBar {
+	
+	
+	public OSXTitleBar() {
+		addTitleBarControl(createTitleBarControl());
+	}
+	
+	@Override
+	protected void paintTitle(Graphics2D g2) {
+		FontMetrics fm = g2.getFontMetrics();
+        int titleWidth = SwingUtilities.computeStringWidth(fm, title);
+        g2.setColor(Color.WHITE);
+        Rectangle r = g2.getClipBounds();
+        int textX = (r.width - titleWidth) / 2;
+        int textY = ((r.height) / 2) - ((fm.getAscent() + fm.getDescent()) / 2) + fm.getAscent();
+        g2.drawString(title, textX + 1, textY + 1);
+        g2.setColor(Color.BLACK);
+        g2.drawString(title, textX, textY);
+	}
+	
+	@Override
+	protected void fillTitleBar(Graphics2D g2) {
+		Paint oldPaint = g2.getPaint();
+        Stroke oldStroke = g2.getStroke();
+        
+        g2.setColor(new Color(241,241,241));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(0, 0, getWidth(), 0);
+        
+        LinearGradientPaint p = new LinearGradientPaint(
+        	1f, 1f, 1f, getHeight() - 1,
+        		new float[] { 0.0f, 0.499f, 0.5f, 1.0f },
+        			new Color[] { new Color(230, 230, 230), new Color(202, 202, 202),
+        				new Color(202, 202, 202), new Color(178, 178, 178) });
+        g2.setPaint(p);
+        g2.fillRect(0, 0, getWidth(), this.getHeight() - 1);
+        
+        
+        g2.setPaint(oldPaint);
+        g2.setColor(new Color(104, 104, 104));
+        g2.setStroke(new BasicStroke(1));
+        g2.drawLine(getX(), getHeight() - 1, getWidth(), getHeight() - 1);
+        
+        g2.setStroke(oldStroke);
+	}
+	
+	private TitleBarControl createTitleBarControl() {
+		OSXTitleBarControl control = new OSXTitleBarControl();
+		control.setPreferredSize(new Dimension(60,20));
+		control.setControlLocation(TitleBar.Location.LEFT);
+		return control;
+	}
+	
+	class OSXTitleBarControl extends TitleBarControl {
+		private static final int SIDE_MARGIN = 8;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean mouseOverControl;
+    	private boolean maskMinimized;
+    	private boolean maskMaximized;
+    	private boolean maskClosed;
+    	
+    	private java.awt.Frame hostFrame;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public OSXTitleBarControl() {
+    		getParentFrame();
+    	}
+    	
+    	@Override
+    	public void paint(Graphics graphics) {
+    		Graphics2D g = (Graphics2D)graphics;
+    		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+    		
+    		if(!shapesInitialized) {
+    			createControlShapes();
+    			installListeners();
+    			shapesInitialized = true;
+    		}
+    		
+    		paintRedButton(g);
+    		paintYellowButton(g);
+    		paintGreenButton(g);
+    	}
+    	
+    	private void paintRedButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)closeRect.getX(), (int)closeRect.getY() + 1, (int)closeRect.getWidth() - 1, (int)closeRect.getHeight());
+    		g2.setColor(new Color(134, 56, 51));
+    		g2.drawOval((int)closeRect.getX(), (int)closeRect.getY(), (int)closeRect.getWidth(), (int)closeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getCenterY()),
+    			(float)closeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(255,90,79), new Color(211,74,54) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getY() + (closeRect.getHeight() * 1.5) + 5),
+    			(float)closeRect.getWidth() - 2, new Point2D.Double(closeRect.getCenterX(), closeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 175), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(closeRect.getCenterX(), closeRect.getCenterY()), (float)closeRect.getWidth() * 1.5f,
+    			new Point2D.Double(closeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    		
+    		if(mouseOverControl) {
+    			g2.setColor(new Color(119,19,17));//90,11,10 -=-  119,19,17
+    			g2.setStroke(new BasicStroke(2));
+    			g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getY() + 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getMaxY() - 3);
+    			g2.drawLine((int)closeRect.getX() + 3, (int)closeRect.getMaxY() - 3, (int)closeRect.getMaxX() - 3, (int)closeRect.getY() + 3);
+    			g2.setStroke(oldStroke);
+    		}
+    		
+    		if(maskClosed) {
+    			g2.setColor(new Color(0,0,0,75));
+    			g2.fillOval((int)closeRect.getX() + 1, (int)closeRect.getY() + 1, (int)closeRect.getWidth(), (int)closeRect.getHeight() - 1);
+    		}
+    	}
+    	
+    	private void paintYellowButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)minimizeRect.getX(), (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth() - 1, (int)minimizeRect.getHeight());
+    		g2.setColor(new Color(115, 84, 47));
+    		g2.drawOval((int)minimizeRect.getX(), (int)minimizeRect.getY(), (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getCenterY()),
+    			(float)minimizeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(238,202,99), new Color(237,166,72) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getY() + (minimizeRect.getHeight() * 1.5) + 5),
+    			(float)minimizeRect.getWidth() - 2, new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 250), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(minimizeRect.getCenterX(), minimizeRect.getCenterY()), (float)minimizeRect.getWidth() * 1.5f,
+    			new Point2D.Double(minimizeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    		
+    		if(mouseOverControl) {
+    			g2.setColor(new Color(102,36,0));
+    			g2.drawLine((int)minimizeRect.getX() + 2, (int)minimizeRect.getCenterY(), (int)minimizeRect.getMaxX() - 2, (int)minimizeRect.getCenterY());
+    			g2.setColor(new Color(166,99,1));
+    			g2.drawLine((int)minimizeRect.getX() + 2, (int)minimizeRect.getCenterY() + 1, (int)minimizeRect.getMaxX() - 2, (int)minimizeRect.getCenterY() + 1);
+    		}
+    		
+    		if(maskMinimized) {
+    			g2.setColor(new Color(0,0,0,75));
+    			g2.fillOval((int)minimizeRect.getX() + 1, (int)minimizeRect.getY() + 1, (int)minimizeRect.getWidth(), (int)minimizeRect.getHeight() - 1);
+    		}
+    	}
+    	
+    	private void paintGreenButton(Graphics2D g2) {
+    		Color white = Color.white;
+    		Paint old = g2.getPaint();
+    		Stroke oldStroke = g2.getStroke();
+    		g2.setStroke(new BasicStroke(2));
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.drawOval((int)maximizeRect.getX(), (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth() - 1, (int)maximizeRect.getHeight());
+    		g2.setColor(new Color(74, 96, 59));
+    		g2.drawOval((int)maximizeRect.getX(), (int)maximizeRect.getY(), (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight());
+    		
+    		Paint p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getCenterY()),
+    			(float)maximizeRect.getWidth() / 2.0f, new float[] { 0.0f, 1.0f }, new Color[] { new Color(194,242,147), new Color(116,174,86) });
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getY() + (maximizeRect.getHeight() * 1.5) + 5),
+    			(float)maximizeRect.getWidth() - 2, new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getHeight() * 3),
+    				new float[] { 0.0f, 00.8f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 250), 
+    					new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE,
+    						RadialGradientPaint.ColorSpaceType.SRGB, AffineTransform.getScaleInstance(1.0, 0.5));
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		p = new RadialGradientPaint(new Point2D.Double(maximizeRect.getCenterX(), maximizeRect.getCenterY()), (float)maximizeRect.getWidth() * 1.5f,
+    			new Point2D.Double(maximizeRect.getCenterX(), 6), new float[] { 0.0f, 0.3f }, new Color[] { new Color(white.getRed(), white.getGreen(), white.getBlue(), 255),
+    				new Color(white.getRed(), white.getGreen(), white.getBlue(), 0) }, RadialGradientPaint.CycleMethod.NO_CYCLE);
+    		g2.setPaint(p);
+    		g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		
+    		g2.setPaint(old);
+    		g2.setStroke(oldStroke);
+    		
+    		if(mouseOverControl) {
+    			g2.setColor(new Color(0,53,-0));
+    			g2.setStroke(new BasicStroke(1));
+    			g2.drawLine((int)maximizeRect.getX() + 2, (int)maximizeRect.getCenterY(), (int)maximizeRect.getMaxX() - 2, (int)maximizeRect.getCenterY());
+    			g2.setColor(new Color(45,118,0));
+    			g2.drawLine((int)maximizeRect.getX() + 2, (int)maximizeRect.getCenterY() + 1, (int)maximizeRect.getMaxX() - 2, (int)maximizeRect.getCenterY() + 1);
+    			g2.setStroke(new BasicStroke(2));
+    			g2.setColor(new Color(0,53,-0));
+    			g2.drawLine((int)maximizeRect.getCenterX(), (int)maximizeRect.getY() + 2, (int)maximizeRect.getCenterX(), (int)maximizeRect.getY() + 3);
+    			g2.setColor(new Color(45,118,0));
+    			g2.drawLine((int)maximizeRect.getCenterX(), (int)maximizeRect.getY() + 3, (int)maximizeRect.getCenterX(), (int)maximizeRect.getMaxY() - 2);
+    		}
+    		
+    		if(maskMaximized) {
+    			g2.setColor(new Color(0,0,0,75));
+    			g2.fillOval((int)maximizeRect.getX() + 1, (int)maximizeRect.getY() + 1, (int)maximizeRect.getWidth(), (int)maximizeRect.getHeight() - 1);
+    		}
+    	}
+    	
+    	private void createControlShapes() {
+    		int y = ((getHeight() - 10) / 2) - 1;
+    		closeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 10, 10);
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN + 20, y, 10, 10);
+    		maximizeRect = new Rectangle(SIDE_MARGIN + 40, y, 10, 10);
+    	}
+    	
+    	private void installListeners() {
+    		final Rectangle2D localCloseRect = new Rectangle2D.Double(
+				closeRect.getX() - 4, closeRect.getY() - 4, 
+					closeRect.getWidth() + 8, closeRect.getHeight() + 8);
+			final Rectangle2D localMinimizeRect = new Rectangle2D.Double(
+				minimizeRect.getX() - 4, minimizeRect.getY() - 4, 
+					minimizeRect.getWidth() + 8, minimizeRect.getHeight() + 8);
+			final Rectangle2D localMaximizeRect = new Rectangle2D.Double(
+				maximizeRect.getX() - 4, maximizeRect.getY() - 4, 
+					maximizeRect.getWidth() + 8, maximizeRect.getHeight() + 8);
+			
+			Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
+				 public void eventDispatched(AWTEvent e) {
+					 if(e.getID() == MouseEvent.MOUSE_RELEASED && mouseOverControl) {
+						 maskMinimized = maskMaximized = maskClosed = mouseOverControl = false;
+						 repaint();
+					 }
+				 }
+			}, AWTEvent.MOUSE_EVENT_MASK);
+    			
+    		addMouseListener(new MouseAdapter() {
+    			public void mouseReleased(MouseEvent e) {
+    				if(localMinimizeRect.contains(e.getPoint())) {
+    					fireFrameWillBecomeIconized();
+    					hostFrame.setExtendedState(JFrame.ICONIFIED);
+    				}else if(localMaximizeRect.contains(e.getPoint())) {
+    					if((hostFrame.getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+    						hostFrame.setExtendedState(JFrame.NORMAL);
+    					}else{
+    						hostFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
+    					}
+    				}else if(localCloseRect.contains(e.getPoint())) {
+    					WindowEvent wev = new WindowEvent(hostFrame, WindowEvent.WINDOW_CLOSING);
+    	                Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(wev);
+    				}
+    				maskMinimized = maskMaximized = maskClosed = false;
+    				repaint();
+    			}
+    			public void mousePressed(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p)) {
+						maskClosed = true;
+						maskMinimized = false;
+						maskMaximized = false;
+					}else if(localMinimizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = true;
+						maskMaximized = false;
+					}else if(localMaximizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = true;
+					}
+    				repaint();
+    			}
+    		});
+    		OSXTitleBarControl.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p) || localMinimizeRect.contains(p) || localMaximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					mouseOverControl = false;
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+    				}
+    				repaint();
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p) || localMinimizeRect.contains(p) || localMaximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						repaint();
+    				}
+    			}
+    		});
+    		OSXTitleBar.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				boolean prev = mouseOverControl;
+    				mouseOverControl = false;
+    				maskClosed = false;
+					maskMinimized = false;
+					maskMaximized = false;
+    				if(prev) {
+    					repaint();
+    				}
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(localCloseRect.contains(p) || localMinimizeRect.contains(p) || localMaximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						repaint();
+    				}
+    			}
+    		});
+    	}
+    	
+    	private void getParentFrame() {
+    		(new Thread() {
+    			public void run() {
+    				while(hostFrame == null) {
+	    				try{ Thread.sleep(100); }catch(Exception e) { e.printStackTrace(); }
+	    				SwingUtilities.invokeLater(new Runnable() {
+	    					public void run() {
+	    						hostFrame = (java.awt.Frame)SwingUtilities.getAncestorOfClass(DesktopFrame.class, OSXTitleBarControl.this);
+	    					}
+	    				});
+    				}
+    			}
+    		}).start();
+    	}
+	}
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/SwingContainer.java b/pivot-wtk/src/org/apache/pivot/wtk/SwingContainer.java
new file mode 100644
index 0000000..e2c86c3
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/SwingContainer.java
@@ -0,0 +1,332 @@
+package org.apache.pivot.wtk;
+
+import java.awt.AWTEvent;
+import java.awt.Point;
+import java.awt.Toolkit;
+import java.awt.event.AWTEventListener;
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowStateListener;
+
+import javax.swing.JFrame;
+import javax.swing.JWindow;
+
+import org.apache.pivot.wtk.Component;
+import org.apache.pivot.wtk.Container;
+import org.apache.pivot.wtk.ContainerListener;
+import org.apache.pivot.wtk.DesktopFrame;
+import org.apache.pivot.wtk.DesktopFrame.DragListener;
+import org.apache.pivot.wtk.Display;
+import org.apache.pivot.wtk.ImageView;
+import org.apache.pivot.wtk.Skin;
+import org.apache.pivot.wtk.TitleBar;
+import org.apache.pivot.wtk.skin.PanelSkin;
+
+
+/**
+ * <pre>
+ *     
+ *     
+ *     -------------------------- o
+ *     |  o                      |  o  	   <---- Apache Pivot Component residing in the Pivot host component.
+ *     |       o                 |     o
+ *     |            o  -------------------
+ *     |               |                 | 
+ *     |               |                 |
+ *     |               |                 | <---- Swing JWindow delegate which receives size information
+ *     |               |                 |		 and calculates location information translated to screen
+ *     |               |                 |		 coordinates from messages delegated from the Apache Pivot
+ *     |               |                 |       component.
+ *     |               |                 |
+ *     |               |                 |
+ *	   |               |                 |         
+ *	   ----------------|                 |
+ *       o             |                 |
+ *             o       |                 |
+ *                   o -------------------
+ *
+ *
+ *
+ * Apache Pivot container which resides within the layout of the parent host.
+ * This container is never seen due to the delegate Swing JWindow which covers
+ * it, maintaining size and position information delegated to it from the 
+ * underlying Pivot container. 
+ * 
+ * Because the underlying ui upon receiving focus will come to the front
+ * of the delegate window, a low-level mouse listener is added so that the
+ * delegate window will always remain in front therefore making it appear
+ * as if the Swing component is actually inside the Apache container.
+ * 
+ * When the window containing the parent ui is moved, there will be a delay
+ * within which the delegate window will not move. Once the parent window has
+ * stopped moving briefly, the delegate window will update its position (or size
+ * in the case of resizing) to the "delegator's" position (or size).
+ * 
+ * One approach to dealing with this drawback is to fork the code providing
+ * an "undecorated frame" which subclasses {@link org.apache.pivot.wtk.DesktopApplicationContext.HostFrame}.
+ * The next step is to paint your own titlebar and add {@link MouseListener} to it 
+ * which can receive drag events and update the position of the frame (also causing
+ * the delegate window to update ongoingly and thus keeping the ui positioning 
+ * in sync). see {@link org.apache.pivot.wtk.DesktopFrame} for details
+ *
+ *
+ * @author David Ray
+ * @see org.apache.pivot.wtk.DesktopFrame
+ */
+public class SwingContainer extends Container {
+	private Skin skin;
+	private Delegate delegate;
+	Display display;
+	private java.awt.Window topLevelWindow;
+	private java.awt.Insets insets;
+	private javax.swing.Timer visibilityTimer;
+	
+	
+	/**
+	 * Creates a new {@code SwingContainer}
+	 * @param parent 	the immediate parent container
+	 */
+	public SwingContainer() {
+		installSkin(ImageView.class);
+		delegate = new Delegate();
+		
+		//Keeps the delegate window in front.
+		Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
+			@Override
+			public void eventDispatched(AWTEvent event) {
+				if(event.getID() == MouseEvent.MOUSE_PRESSED) {
+					delegate.toFront();				
+				}
+			}
+		}, AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK);
+		
+		(new Thread() {
+			public void run() {
+				while (getParent() == null || (display = getParent().getDisplay()) == null) {
+					try { Thread.sleep(2000); } catch(Exception e) { e.printStackTrace(); }
+				}
+				
+				getParent().getContainerListeners().add(createContainerListener());
+				
+				topLevelWindow = display.getHostWindow();
+				if(topLevelWindow instanceof DesktopFrame) {
+					((DesktopFrame)topLevelWindow).addDragListener(new DragListener() {
+						public void windowDragged(Point oldLoc, Point newLoc) {
+							delegate.setVisible(false);
+						}
+						public void draggingStopped() {
+							Point p = getLocationOnScreen();
+							moveWindow(p.x, p.y);
+							delegate.setVisible(true);
+						}
+					});
+					((DesktopFrame)topLevelWindow).addWindowStateListener(new WindowStateListener() {
+						@Override
+						public void windowStateChanged(WindowEvent e) {
+							if((e.getNewState() & JFrame.ICONIFIED) == JFrame.ICONIFIED) {
+								delegate.setVisible(false);
+							}else{
+								delegate.setVisible(true);
+								delegate.toFront();
+							}
+						}
+					});
+					TitleBar tb = ((DesktopFrame)topLevelWindow).getTitleBar();
+					if(tb != null) {
+						tb.addIconizeListener(new TitleBar.IconizeListener() {
+							@Override
+							public void frameWillIconize() {
+								delegate.setVisible(false);
+							}
+						});
+					}
+				}
+				topLevelWindow.addComponentListener(new ComponentAdapter() {
+					@Override
+					public void componentMoved(ComponentEvent e) {
+						Point p = getLocationOnScreen();
+						moveWindow(p.x, p.y);
+					}
+				});
+			}
+		}).start();
+		
+		visibilityTimer = new javax.swing.Timer(250, new java.awt.event.ActionListener() {
+			public void actionPerformed(java.awt.event.ActionEvent e) {
+				delegate.setVisible(true);
+				delegate.requestFocus();
+			}
+		});
+		
+		visibilityTimer.setRepeats(false);
+		
+	}
+	
+	/**
+	 * Listener which ensures that this "layered" container is visible.
+	 * @return	ContainerListener
+	 */
+	private ContainerListener createContainerListener() {
+		return new ContainerListener.Adapter() {
+			@Override
+			public void componentInserted(Container container, int index) {
+				delegate.setVisible(true);
+			}
+		};
+	}
+	
+	
+	/**
+	 * Routes size information to the delegate
+	 * 
+	 * @param	w	width 
+	 * @param	h	height
+	 */
+	public void setSize(int w, int h) {
+		visibilityTimer.restart();
+		delegate.setVisible(false);
+		super.setSize(w,h);
+		resizeWindow(w, h);
+		invalidate();
+		repaint();
+	}
+	
+	/**
+	 * Routes location information to the delegate.
+	 * 
+	 * @param	x coordinate
+	 * @param	y coordinate
+	 */
+	public void setLocation(int x, int y) {
+		super.setLocation(x,y);
+		java.awt.Point convertedPoint = getLocationOnScreen();
+		moveWindow(convertedPoint.x, convertedPoint.y);
+	}
+	
+	/**
+	 * Method used to add the Swing component to be hosted
+	 * by this container.
+	 * 
+	 * @param c		a java.awt.Component
+	 */
+	public void addSwingComponent(java.awt.Component c) {
+		if(c == null) {
+			throw new IllegalArgumentException("Component \"c\" cannot be null");
+		}
+		java.awt.Component child = delegate.getChild();
+		if(child != null) {
+			delegate.remove(child);
+		}
+		delegate.add(c);
+	}
+	
+	/**
+	 * Calculates the screen coordinates of this container which
+	 * are used to relocate the delegate window.
+	 * 
+	 * @return	java.awt.Point 	the new screen coordinates of the delegate
+	 */
+	public java.awt.Point getLocationOnScreen() {
+		int xLocal = 0;
+        int yLocal = 0;
+
+        Component component = this;
+        while (component != null && component.isVisible()) {
+        	if(component instanceof Display) { 
+        		java.awt.Window window = ((Display)component).getHostWindow();
+        		xLocal += window.getX();
+                yLocal += window.getY();
+                if(window instanceof DesktopFrame) {
+            		insets = ((DesktopFrame)window).getTitlebarInsets();
+            	}else{
+            		insets = window.getInsets();
+            	}
+                xLocal += insets.left;
+                yLocal += insets.top;
+                break;
+        	}else{
+        		xLocal += component.getX();
+        		yLocal += component.getY();
+        	}
+        	component = component.getParent();
+        }
+        
+        return new java.awt.Point(xLocal, yLocal);
+	}
+	
+	/**
+	 * Moves the delegate window to the specified coordinates.
+	 * 
+	 * @param x		the horizontal coordinate
+	 * @param y		the vertical coordinate
+	 */
+	public void moveWindow(int x, int y) {
+		delegate.setLocation(x, y);
+		delegate.toFront();
+	}
+	
+	/**
+	 * Resizes the delegate window to the specified size.
+	 * 
+	 * @param w		the new delegate width
+	 * @param h		the new delegate height
+	 */
+	public void resizeWindow(int w, int h) {
+		delegate.setSize(w,h);
+		delegate.toFront();
+	}
+	
+	/**
+	 * Overridden to install a NOOP skin basically
+	 * 
+	 * @param		componentClass 	ignored
+	 */
+	@Override
+    protected void installSkin(Class<? extends org.apache.pivot.wtk.Component> componentClass) {
+    	skin = new PanelSkin();
+    	setSkin(skin);
+    }
+	
+	/**
+	 * 	Delegate {@link JWindow} which contains the Swing component which
+	 * is kept in sync with the Apache Pivot component {@link SwingContainer}
+	 * @author David Ray
+	 */
+	@SuppressWarnings("serial")
+	private class Delegate extends JWindow {
+		private java.awt.Component child;
+		
+		public Delegate() {
+//			JRootPane root = getRootPane();
+//			root.putClientProperty("Window.shadow", Boolean.FALSE);
+		}
+		
+		@Override
+		public java.awt.Component add(java.awt.Component c) {
+			this.child = c;
+			return super.add(c);
+		}
+		
+		@Override
+		public void setSize(int w, int h) {
+			super.setSize(w, h);
+			child.setSize(w, h);
+		}
+		
+		private java.awt.Component getChild() {
+			return child;
+		}
+		
+		@Override
+		public void remove(java.awt.Component c) {
+			super.remove(c);
+			if(c == child) {
+				child = null;
+			}
+		}
+	}
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
new file mode 100644
index 0000000..c4f621f
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBar.java
@@ -0,0 +1,149 @@
+package org.apache.pivot.wtk;
+
+import java.awt.BorderLayout;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.RenderingHints;
+import java.awt.event.MouseEvent;
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Titlebar to be used with the {@link DesktopFrame} class which provides
+ * template methods for styling the titlebar, inserting the control buttons
+ * (see {@link TitleBarControl}) and managing the frame's state.
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public abstract class TitleBar extends java.awt.Panel implements java.awt.event.MouseListener {
+	public enum Location { LEFT, CENTER, RIGHT };
+	
+	List<IconizeListener> iconizeListeners = new ArrayList<IconizeListener>();
+	
+	protected TitleBarControl control;
+	protected String title;
+	
+	public TitleBar() {
+		this("");
+	}
+	
+	public TitleBar(String title) {
+		this.title = title;
+		setLayout(new BorderLayout());
+	}
+	
+	public void addIconizeListener(IconizeListener l) {
+		if(l != null) {
+			iconizeListeners.add(l);
+		}
+	}
+	
+	public void removeIconizeListener(IconizeListener l) {
+		iconizeListeners.remove(l);
+	}
+	
+	public void fireFrameWillBecomeIconized() {
+		for(IconizeListener l : iconizeListeners) {
+			l.frameWillIconize();
+		}
+	}
+	
+	public boolean isControlHit(MouseEvent m) {
+		if(control != null) {
+			return control.isControlHit(m);
+		}
+		return false;
+	}
+	
+	public void setTitle(String title) {
+		this.title = title;
+	}
+	
+	@Override
+	public void mousePressed(MouseEvent m) {
+		if(control == null) return;
+		control.mousePressed(m);
+	}
+	
+	@Override
+	public void mouseReleased(MouseEvent m) {
+		if(control == null) return;
+		control.mouseReleased(m);
+	}
+	
+	//NO-OP
+	@Override public void mouseClicked(MouseEvent e) {}
+	@Override public void mouseEntered(MouseEvent e) {}
+	@Override public void mouseExited(MouseEvent e) {}
+	
+	/**
+	 * Adds the component housing the window controls (i.e. minimize/maximize buttons)
+	 * to this {@code TitleBar}
+	 * 
+	 * @param c		Subclass of {@link TitleBarControl}
+	 */
+	public void addTitleBarControl(TitleBarControl c) {
+		this.control = c;
+		if(this.control != null) {
+			remove(control);
+		}
+		
+		this.control = c;
+		switch(control.getControlLocation()) {
+			case LEFT: add(c, BorderLayout.WEST); break;
+			case CENTER: add(c, BorderLayout.CENTER); break;
+			case RIGHT : add(c, BorderLayout.EAST); break;
+		}
+	}
+	
+	/**
+	 * Returns this {@code TitleBar}'s {@link TitleBarControl} if
+	 * any exists.
+	 * 
+	 * @return	the installed {@code TitleBarControl}
+	 */
+	public TitleBarControl getTitleBarControl() {
+		return control;
+	}
+	
+	@Override
+	public void paint(Graphics g) {
+        Graphics2D g2 = (Graphics2D)g;
+        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        
+        fillTitleBar(g2);
+        
+        //if clip is for child(i.e. TitleBarControl) don't paint it now.
+        //The clip indicates what's being painted. If the clip is the
+        //size of the titlebar then paint the title otherwise if the 
+        //clip is the clip representing the control, don't paint the 
+        //title into it, since we don't want them to overlap.
+        if(g2.getClipBounds().getSize().equals(getSize())) {
+        	paintTitle(g2);
+        }
+        //Paint the child component(TitleBarControl)
+        super.paint(g);
+    }
+	
+	@Override
+	public void update(Graphics g) {
+		paint(g);
+	}
+	
+	protected abstract void paintTitle(Graphics2D g2);
+	
+	protected abstract void fillTitleBar(Graphics2D g2);
+	
+	/**
+	 * Listened to by those classes wishing to be informed
+	 * when this {@link TitleBar}'s frame will be iconized.
+	 * 
+	 * @author David Ray
+	 */
+	public interface IconizeListener {
+		public void frameWillIconize();
+	}
+
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
new file mode 100644
index 0000000..bae1038
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/TitleBarControl.java
@@ -0,0 +1,63 @@
+package org.apache.pivot.wtk;
+
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+import javax.swing.JComponent;
+
+
+
+/**
+ * Classes which are intended to provide titlebar control implementations 
+ * should be an extension of this class when used with the {@link TempFrame}
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public abstract class TitleBarControl extends java.awt.Component implements MouseListener, MouseMotionListener {
+	private TitleBar.Location titleBarLoc = TitleBar.Location.RIGHT;
+	
+	@Override
+	public void mouseDragged(MouseEvent e) {}
+
+	@Override
+	public void mouseMoved(MouseEvent e) {}
+
+	@Override
+	public void mouseClicked(MouseEvent e) {}
+
+	@Override
+	public void mousePressed(MouseEvent e) {}
+
+	@Override
+	public void mouseReleased(MouseEvent e) {}
+
+	@Override
+	public void mouseEntered(MouseEvent e) {}
+
+	@Override
+	public void mouseExited(MouseEvent e) {}
+	
+	/**
+	 * Sets the title bar location, see {@link TitleBar.Location}
+	 * 
+	 * @param loc
+	 */
+	public void setControlLocation(TitleBar.Location loc) {
+		if(loc == null) throw new NullPointerException("location can not be null");
+		this.titleBarLoc = loc;
+	}
+
+	/**
+	 * Returns the {@link TitleBar.Location}
+	 * @return	the {@link TitleBar.Location} of the control
+	 */
+	public TitleBar.Location getControlLocation() {
+		return this.titleBarLoc;
+	}
+	
+	public boolean isControlHit(MouseEvent e) {
+		return this.getBounds().contains(e.getPoint());
+	}
+}
diff --git a/pivot-wtk/src/org/apache/pivot/wtk/WindowsTitleBar.java b/pivot-wtk/src/org/apache/pivot/wtk/WindowsTitleBar.java
new file mode 100644
index 0000000..368a001
--- /dev/null
+++ b/pivot-wtk/src/org/apache/pivot/wtk/WindowsTitleBar.java
@@ -0,0 +1,431 @@
+package org.apache.pivot.wtk;
+
+import java.awt.AWTEvent;
+import java.awt.AlphaComposite;
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Composite;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.MultipleGradientPaint.CycleMethod;
+import java.awt.Polygon;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+import java.awt.event.AWTEventListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.WindowEvent;
+import java.awt.geom.Area;
+import java.awt.geom.GeneralPath;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.ConvolveOp;
+import java.awt.image.Kernel;
+
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+
+
+/**
+ * Mockup of a "Windows 7" titlebar, giving a "windowsy" look and
+ * feel when used in conjunction with a custom frame on a Windows 7
+ * os.
+ * 
+ * @author David Ray
+ */
+@SuppressWarnings("serial")
+public class WindowsTitleBar extends TitleBar {
+	
+	/**
+	 * Constructs a new {@code WindowsTitleBar}
+	 */
+	public WindowsTitleBar() {
+		addTitleBarControl(createTitleBarControl());
+	}
+	
+	@Override
+	protected void paintTitle(Graphics2D g2) {
+		// TODO Auto-generated method stub
+
+	}
+	
+	/**
+	 * Called by the {@link TitleBar} base class to paint 
+	 * the background of the titlebar.
+	 */
+	@Override
+	protected void fillTitleBar(Graphics2D g) {
+		Rectangle r = getBounds();
+		Color ltGray = Color.GRAY;
+		g.setColor(ltGray);
+		g.fillRoundRect(0,0,r.width, r.height + 15, 15, 15);
+		g.setColor(Color.BLACK);
+		g.drawRoundRect(0,0,r.width - 1, r.height + 15, 15, 15);
+		g.setColor(Color.WHITE);
+		g.drawRoundRect(1,1,r.width - 3, r.height + 15, 15, 15);
+	}
+	
+	/**
+	 * Creates the control containing the frame state
+	 * management buttons.
+	 * 
+	 * @return	{@link TitleBarControl}
+	 */
+	private TitleBarControl createTitleBarControl() {
+		WindowsTitleBarControl control = new WindowsTitleBarControl();
+		control.setPreferredSize(new Dimension(103,20));
+		control.setControlLocation(TitleBar.Location.RIGHT);
+		return control;
+	}
+	
+	class WindowsTitleBarControl extends TitleBarControl {
+		private static final int SIDE_MARGIN = 3;
+    	private Rectangle2D minimizeRect;
+    	private Rectangle2D maximizeRect;
+    	private Rectangle2D closeRect;
+    	
+    	private boolean mouseOverControl;
+    	private boolean maskMinimized;
+    	private boolean maskMaximized;
+    	private boolean maskClosed;
+    	private boolean overMin;
+    	private boolean overMax;
+    	private boolean overClose;
+    	
+    	private java.awt.Frame hostFrame;
+    	
+    	private boolean shapesInitialized;
+    	
+    	public WindowsTitleBarControl() {
+    		getParentFrame();
+    	}
+    	
+    	@Override
+    	public void paint(Graphics graphics) {
+    		super.paint(graphics);
+    		Graphics2D g = (Graphics2D)graphics;
+    		if(!shapesInitialized) {
+    			createTargetShapes();
+    			installListeners();
+    			shapesInitialized = true;
+    		}
+    		
+    		paintControl(g);
+    	}
+    	
+    	@Override
+    	public void update(Graphics g) {
+    		paint(g);
+    	}
+    	
+    	protected void paintControl(Graphics2D g) {
+    		Rectangle r = g.getClipBounds();
+    		Graphics2D g2 = (Graphics2D)g;
+    		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
+    		
+    		//The control box
+    		g2.setColor(Color.BLACK);
+    		g2.drawRoundRect(r.width - 99, -10, 90, 29, 10, 10);
+    		g2.setColor(Color.WHITE);
+    		g2.drawRoundRect(r.width - 100, -9, 92, 29, 10, 10);
+    		
+    		//The controls
+    		int x = r.width - 98;
+    		GeneralPath path = new GeneralPath();
+    		
+    		//Button 1
+    		path.moveTo(x, 2);
+    		path.lineTo(x, 14);
+    		path.curveTo(x, 14, x, 16, x + 4, 18);
+    		path.lineTo(x + 23, 18);
+    		path.lineTo(x + 23, 2);
+    		g2.draw(path);
+    		
+    		//Button 2
+    		g2.setColor(Color.BLACK);
+    		g2.drawLine(x + 24, 0, x + 24, 18);
+    		g2.setColor(Color.WHITE);
+    		g2.drawLine(x + 25, 2, x + 25, 18);
+    		g2.drawLine(x + 25, 18, x + 47, 18);
+    		g2.drawLine(x + 47, 18, x + 47, 2);
+    		
+    		//Button 3
+    		g2.setColor(Color.BLACK);
+    		g2.drawLine(x + 48, 18, x + 48, 0);
+    		g2.setColor(Color.WHITE);
+    		path.moveTo(x + 49, 2);
+    		path.lineTo(x + 49, 18);
+    		path.lineTo(x + 85, 18);
+    		path.curveTo(x + 85, 18, x + 85, 16, x + 88, 14);
+    		path.lineTo(x + 88, 2);
+    		g2.draw(path);
+    		g2.setColor(new Color(186,56,33));
+    		g2.fillRect(x + 49, 1, 38, 18);
+    		g2.fillRect(x + 49, 1, 40, 15);
+    		g2.drawLine(x + 49, 16, x + 88, 16);
+    		g2.drawLine(x + 49, 17, x + 87, 17);
+    		
+//    		image = getGaussianBlurFilter(5, true).filter(image, null);
+//    		image = getGaussianBlurFilter(5, false).filter(image, null);
+//    		
+//    		g.drawImage(image, 0, 0, null);
+//    		
+//    		g2.dispose();
+    		
+    		//Reflection on upper half of all 3 buttons
+    		Composite oldComp = g2.getComposite();
+    		g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    		
+    		Point2D start = new Point2D.Double(x, 2);
+    		Point2D end = new Point2D.Double(x, 9);
+    		float[] fractions = new float[] { 0.0f, 1.0f };
+    		Color[] colors = new Color[] { Color.WHITE, Color.GRAY };
+    		java.awt.LinearGradientPaint lgp = new java.awt.LinearGradientPaint(start, end, fractions, colors, CycleMethod.NO_CYCLE);
+    		
+    		g2.setPaint(lgp);//Color.WHITE);
+    		g2.fillRect(x, 2, 23, 9); //Button 1
+    		g2.fillRect(x + 25, 2, 23, 9); //Button 2
+    		g2.fillRect(x + 48, 1, 41, 9); //Button 3
+    		
+    		g2.setComposite(AlphaComposite.SrcOver.derive(0.5f));
+    		start = new Point2D.Double(x, 9);
+    		end = new Point2D.Double(x, 18);
+    		fractions = new float[] { 0.0f, 1.0f };
+    		colors = new Color[] { Color.DARK_GRAY, Color.LIGHT_GRAY };
+    		lgp = new java.awt.LinearGradientPaint(start, end, fractions, colors, CycleMethod.NO_CYCLE);
+    		
+//    		g2.setPaint(lgp);
+//    		g2.fillRect(x, 10, 23, 16); //Button 1
+//    		g2.fillRect(x + 25, 10, 23, 16); //Button 2
+//    		g2.fillRect(x + 48, 10, 41, 17); //Button 3
+    		
+    		g2.setComposite(oldComp); //Reverse alpha composite
+    		
+    		//Button symbols
+    		g2.setColor(Color.WHITE);
+    		g2.fillRect(x + 7, 11, 10, 3);
+    		g2.setColor(Color.BLACK);
+    		g2.drawRect(x + 7, 10, 10, 4);
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.setStroke(new BasicStroke(2));
+    		g2.drawRect(x + 31, 6, 10, 7);
+    		g2.setColor(Color.BLACK);
+    		g2.setStroke(new BasicStroke(1));
+    		g2.drawRect(x + 30, 5, 12, 9);
+    		g2.drawRect(x + 33, 8, 6, 3);
+    		
+    		Area xfig = new Area(new Rectangle(x + 62, 5, 14, 8));
+    		int[] xpoints = new int[]{ x + 62, x + 66, x + 62 };
+    		int[] ypoints = new int[] { 5, 9, 13 };
+    		Polygon p = new Polygon(xpoints, ypoints, 3);
+    		Area leftTri = new Area(p);
+    		xfig.subtract(leftTri);
+    		xpoints = new int[]{ x + 66, x + 69, x + 72 };
+    		ypoints = new int[] { 5, 8, 5 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area topTri = new Area(p);
+    		xfig.subtract(topTri);
+    		xpoints = new int[]{ x + 76, x + 72, x + 76 };
+    		ypoints = new int[] { 5, 9, 13 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area rightTri = new Area(p);
+    		xfig.subtract(rightTri);
+    		xpoints = new int[]{ x + 66, x + 69, x + 72 };
+    		ypoints = new int[] { 13, 10, 13 };
+    		p = new Polygon(xpoints, ypoints, 3);
+    		Area bottomTri = new Area(p);
+    		xfig.subtract(bottomTri);
+    		
+    		g2.setColor(Color.WHITE);
+    		g2.fill(xfig);
+    		g2.setColor(Color.BLACK);
+    		g2.draw(xfig);
+    		
+    		if(mouseOverControl) {
+    			if(maskMinimized) {
+    				g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    				g2.setColor(Color.DARK_GRAY);
+    				g2.fill(minimizeRect);
+    			}else if(maskMaximized) {
+    				g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    				g2.setColor(Color.DARK_GRAY);
+    				g2.fill(maximizeRect);
+    			}else if(maskClosed) {
+    				g2.setComposite(AlphaComposite.SrcOver.derive(0.3f));
+    				g2.setColor(Color.DARK_GRAY);
+    				g2.fill(closeRect);
+    			}
+    			
+    			g2.setComposite(oldComp);
+    		}
+    	}
+    	
+    	private void createTargetShapes() {
+    		int y =  1;
+    		minimizeRect = new Rectangle2D.Double(SIDE_MARGIN, y, 25, 20);
+    		maximizeRect  = new Rectangle2D.Double(SIDE_MARGIN + 25, y, 25, 20);
+    		closeRect = new Rectangle(SIDE_MARGIN + 50, y, 40, 20);
+    	}
+    	
+    	private void installListeners() {
+    		Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {
+				 public void eventDispatched(AWTEvent e) {
+					 if(e.getID() == MouseEvent.MOUSE_RELEASED && mouseOverControl) {
+						 maskMinimized = maskMaximized = maskClosed = mouseOverControl = false;
+						 repaint();
+					 }
+				 }
+			}, AWTEvent.MOUSE_EVENT_MASK);
+    			
+    		addMouseListener(new MouseAdapter() {
+    			public void mouseReleased(MouseEvent e) {
+    				if(minimizeRect.contains(e.getPoint())) {
+    					fireFrameWillBecomeIconized();
+    					hostFrame.setExtendedState(JFrame.ICONIFIED);
+    				}else if(maximizeRect.contains(e.getPoint())) {
+    					if((hostFrame.getExtendedState() & JFrame.MAXIMIZED_BOTH) == JFrame.MAXIMIZED_BOTH) {
+    						hostFrame.setExtendedState(JFrame.NORMAL);
+    					}else{
+    						hostFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
+    					}
+    				}else if(closeRect.contains(e.getPoint())) {
+    					WindowEvent wev = new WindowEvent(hostFrame, WindowEvent.WINDOW_CLOSING);
+    	                Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(wev);
+    				}
+    				maskMinimized = maskMaximized = maskClosed = false;
+    				repaint();
+    			}
+    			public void mousePressed(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(closeRect.contains(p)) {
+						maskClosed = true;
+						maskMinimized = false;
+						maskMaximized = false;
+					}else if(minimizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = true;
+						maskMaximized = false;
+					}else if(maximizeRect.contains(p)) {
+						maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = true;
+					}
+    				repaint();
+    			}
+    		});
+    		WindowsTitleBarControl.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if((overClose = closeRect.contains(p)) || (overMin = minimizeRect.contains(p)) || (overMax = maximizeRect.contains(p))) {
+    					mouseOverControl = true;
+    					overClose = !overMin && !overMax;
+    					overMin = !overClose && !overMax;
+    					overMax = !overMin && !overClose;
+    				}else{
+    					mouseOverControl = false;
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						overMin = false;
+						overClose = false;
+						overMax = false;
+    				}
+    				
+    				repaint();
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(closeRect.contains(p) || minimizeRect.contains(p) || maximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						
+						repaint();
+    				}
+    			}
+    		});
+    		WindowsTitleBar.this.addMouseMotionListener(new MouseAdapter() {
+    			public void mouseMoved(MouseEvent m) {
+    				boolean prev = mouseOverControl;
+    				mouseOverControl = false;
+    				maskClosed = false;
+					maskMinimized = false;
+					maskMaximized = false;
+    				if(prev) {
+    					repaint();
+    				}
+    			}
+    			public void mouseDragged(MouseEvent m) {
+    				java.awt.Point p = m.getPoint();
+    				if(closeRect.contains(p) || minimizeRect.contains(p) || maximizeRect.contains(p)) {
+    					mouseOverControl = true;
+    				}else{
+    					maskClosed = false;
+						maskMinimized = false;
+						maskMaximized = false;
+						repaint();
+    				}
+    			}
+    		});
+    	}
+    	
+    	private void getParentFrame() {
+    		(new Thread() {
+    			public void run() {
+    				while(hostFrame == null) {
+	    				try{ Thread.sleep(100); }catch(Exception e) { e.printStackTrace(); }
+	    				SwingUtilities.invokeLater(new Runnable() {
+	    					public void run() {
+	    						hostFrame = (java.awt.Frame)SwingUtilities.getAncestorOfClass(DesktopFrame.class, WindowsTitleBarControl.this);
+	    						WindowsTitleBar.this.invalidate();
+	    						WindowsTitleBar.this.validate();
+	    						WindowsTitleBar.this.repaint();
+	    					}
+	    				});
+    				}
+    			}
+    		}).start();
+    	}
+	}
+
+	
+	
+	public ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal) {
+	     if (radius < 1) {
+	    	 throw new IllegalArgumentException(
+	             "Radius must be >= 1");
+	     }
+
+	     int size = radius * 2 + 1;
+	     float[] data = new float[size];
+	     float sigma = radius / 3.0f;
+	     float twoSigmaSquare = 2.0f * sigma * sigma;
+	     float sigmaRoot = (float)
+	         Math.sqrt(twoSigmaSquare * Math.PI);
+	     float total = 0.0f;
+	     for (int i = -radius; i <= radius; i++) {
+	    	 float distance = i * i;
+	       	int index = i + radius;
+	       	data[index] = (float) Math.exp(-distance / twoSigmaSquare) / sigmaRoot;
+	       	total += data[index];
+	     }
+
+	     for (int i = 0; i < data.length; i++) {
+	    	 data[i] /= total;
+	     }
+
+	     Kernel kernel = null;
+	     if(horizontal) {
+	    	 kernel = new Kernel(size, 1, data);
+	     }else{
+	    	 kernel = new Kernel(1, size, data);
+	     }
+	     return new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);
+	 }
+
+}
